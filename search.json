[{"title":"Octane的 DASCTF 2022 Nov月赛 Writeup","url":"/posts/5/index.html","content":"这次比赛可以说是本人参加的第一次团队赛。和三位同为22届天枢的同学组了个四人小队。队友：@Clovershrub @DoubleLii @Cabelis\n感觉大部分赛题对于我目前的水平来说是比较难的，比赛期间才解出来三道题，最后队伍积分总榜第十三名orz\n但即使只有三道题，也水一篇WP吧。\n\n比赛地址：https://buuoj.cn/match/matches/172 似乎因为这次比赛总体解题数量也不多，没有发布官方WP。\nMisc七仙女下凡&ensp;&ensp;&ensp;&ensp;开赛之后直奔Misc。发现一道久违的图片隐写题！\n&ensp;&ensp;&ensp;&ensp;题目附件一共七张图，图片内容都是相同的。因此很容易想到将图片合并叠加。先观察一下图片的属性：\n\n&ensp;&ensp;&ensp;&ensp;1.png和2.png的分辨率和大小都是相同的，所以第一步应该是将这两个图片合并。用图片隐写的解密工具stegsolve.jar打开1.png，再用Analyse-&gt;Image_Combiner选项与2.png进行合并，观察一下哪种合并方法是合适的。\n\n&ensp;&ensp;&ensp;&ensp;其他合并方法看起来都挺抽象的，只有Vertical_Interlace竖直交错这个选项比较靠谱。把该选项合并的结果保存为solved2.bmp，发现这个图片的尺寸和大小都与3.png相同。大概已经能猜到这道题是怎么回事了。\n&ensp;&ensp;&ensp;&ensp;尝试将solved2.bmp与3.png合并，此时又能观察到用Horizontal_Interlace水平交错这个选项生成的图片solved3.bmp与4.png看起来差不多，大小与分辨率也相同。如此交替着用竖直交错与水平交错来合并上两张图片合并的结果和下一张图片，一直叠加到最后一张图片。得到一张大小约为9MB的长图。将这张图用stegsolve打开观察一下：\n\n&ensp;&ensp;&ensp;&ensp;在RGB三色的plane0通道下能看到这张图片最上部分有明显痕迹，显然是LSB隐写。以RGB顺序提取LSB，可以从得到的数据中发现ffd8ffe1文件头。\n\n&ensp;&ensp;&ensp;&ensp;将这些数据用Save_Bin选项保存为jpg格式的文件，直接将其打开即可得到含有flag的图片：\n\n\nDASCTF{PnG_havE_tWo_1nTerLaCE_typES}\n\n&ensp;&ensp;&ensp;&ensp;需要注意的是，在将图片逐个合并的过程中一定要按照正确的顺序叠加，即先用stegsolve打开前两张图片合并的结果，再在Image_Combiner选项中选择下一张图片进行叠加。叠加的顺序不同，得到的结果也不同。顺序不正确会导致最终得到的flag图出错。\n&ensp;&ensp;&ensp;&ensp;感觉做这道题时的思路还是比较顺利的。题目不算特别难，但PNG竖直和水平交错的套路还是第一次见到。提交flag后发现居然拿到了全场一血orz\n&ensp;&ensp;\nEzUSB （赛后自行解出）&ensp;&ensp;&ensp;&ensp;解压题目附件，得到一个4GB大小的文件。看题目描述，这个文件似乎是某个U盘的镜像，需要我们来恢复U盘镜像中的数据，找到flag。\n&ensp;&ensp;&ensp;&ensp;首先简单了解一下一个U盘的文件结构是什么样的。\n&ensp;&ensp;&ensp;&ensp;对于MBR硬盘，其最开始部分，即第一个扇区，存储着MBR，用于记录该块硬盘的基本信息和各分区的所在位置。硬盘的每个分区的最开始部分则存储着DBR，记录了本分区的文件系统。\n\n&ensp;&ensp;&ensp;&ensp;用WinHex打开文件，选择”将镜像文件转换为硬盘”选项。可以看到起始扇区和分区1可以被识别出来，但分区1的文件系统类型是未知的。\n\n&ensp;&ensp;&ensp;&ensp;跳转到分区1查看：\n\n&ensp;&ensp;&ensp;&ensp;该分区的开头第一个扇区本应该存储着DBR记录，但却全都是00。而其之后的几个扇区也没有找到看起来像DBR的东西。该DBR很可能是被故意删掉了。\n&ensp;&ensp;&ensp;&ensp;文件最后还有未分区空间，跳转到这里可以发现一段额外的数据，很明显是zip文件头。\n\n&ensp;&ensp;&ensp;&ensp;将该段十六进制数据保存为zip文件并打开，可以得到一个名为DBR的文件。直接将DBR文件的全部数据插入到分区1的第一个扇区。\n\n&ensp;&ensp;&ensp;&ensp;再保存一下。重新打开，此时Winhex已经能够识别分区1的文件系统了，双击分区1就可以直接看到分区1的文件：\n\n&ensp;&ensp;&ensp;&ensp;发现 机密.zip 。flag应该就是在这个文件内。跳转到存储该文件的扇区，仔细观察，这一堆数据最末尾是 4030B405 ，就是zip文件头的倒序。将从扇区开始到 05 的十六进制数据全都倒序过来，就直接能看到flag：\n\n\nDASCTF{y0u_Rea11yr3ally_kN0w_th3_DBR!!!}\n\n\n&ensp;&ensp;&ensp;&ensp;比赛时已经找到了存储 机密.zip 的扇区。但没有看出来zip是倒序存储的，与第四个flag失之交臂…当时还以为是题目的DBR有问题啊orz\n&ensp;&ensp;&ensp;&ensp;后来写wp的时候又发现，直接用DiskGenius的数据恢复，不用修DBR就可以直接找到 机密.zip 的扇区…\n&ensp;&ensp;\nCryptoeazy_hash&ensp;&ensp;&ensp;&ensp;先看题目：\nfrom Crypto.Util.number import bytes_to_long, long_to_bytes\nfrom zlib import crc32\nfrom secret import *\nP = 93327214260434303138080906179883696131283277062733597039773430143631378719403851851296505697016458801222349445773245718371527858795457860775687842513513120173676986599209741174960099561600915819416543039173509037555167973076303047419790245327596338909743308199889740594091849756693219926218111062780849456373\ndef myhash(x):\n    res = []\n    end = b\"\"\n    bytescipher = long_to_bytes(x)\n    a = bytescipher[:len(bytescipher) % 8]\n    res.append(a)\n    res.append(long_to_bytes(crc32(a)))\n    t = (len(bytescipher) // 8)\n    bytescipher = bytescipher[len(bytescipher) % 8:]\n    for i in range(t):\n        a = bytescipher[i*8:i*8+8]\n        res.append(a)\n        res.append(long_to_bytes(crc32(a)))\n    for i in res:\n        end += i\n    res = bytes_to_long(end)\n    res = (res + (res >> 500)) &amp; 2**(500)-1\n    return res\ndef encode(pt):\n    a=[]\n    b=[]\n    a.append(myhash(pt))\n    for i in range(3):\n        a.append(myhash(a[i]))\n    for j in range(4):\n        secret=(a[0] + a[1] * a[j] + a[2] * a[j] ** 2 + a[3] * a[j] ** 3) % P\n        b.append([a[j],secret])\n    return b\npt = bytes_to_long(flag.encode())\nFLAG=encode(pt)\nprint(FLAG[1])\n\n# 输出略\n&ensp;&ensp;&ensp;&ensp;又是一个自制hash函数的题。之前在moectf做过一道ezhash。\n&ensp;&ensp;&ensp;&ensp;首先看看程序输出是什么东西。显然，程序的结果是一个有两个元素的列表。分析encode函数可知，第一个元素是a[1]，第二个元素是secret，即是(a[0]+a[1]*a[1]+a[2]*a[1]**2+a[3]*a[1]**3)%P的结果。已知a[1]与P，a[2]是myhash(a[1])的结果，a[3]是myhash(a[2])的结果。并且易知a[0]远小于P，因此可以解出a[0]的值。\na2 = myhash(a1)\na3 = myhash(a2)\na0 = (a1 * a1 + a2 * a1 ** 2 + a3 * a1 ** 3)//P*P+secret-(a1 * a1 + a2 * a1 ** 2 + a3 * a1 ** 3)\nprint(a0)\n\n# a0 = 2957101726941201632179067084095401321656420466530004630566266527204598229831554134973672777487933790319144163396714765872645685966\n&ensp;&ensp;&ensp;&ensp;a[0]就是flag经过一次myhash运算的结果。直接将a[0]转换为字节，并将结果每隔4个字节取出来8个字节，即可得到flag。\noutput = b''\nfor i in range(len(long_to_bytes(a0))//12):\n    output+=long_to_bytes(a0)[12*i+6:12*i+13]\nprint(output)\n\n# SCTF&#123;ths_is_th_fe3st_uest1on\n&ensp;&ensp;&ensp;&ensp;因此得到flag：\n\nDASCTF{th1s_is_the_fe3st_quest1on}\n\n&ensp;&ensp;\nReversebabyimg&ensp;&ensp;&ensp;&ensp;这次比赛最离谱的一道题…题目给了一张图片和一个程序，需要修好程序，用程序解密图片隐藏的信息才能得到flag\n&ensp;&ensp;&ensp;&ensp;本来是给Reverser做的。但程序似乎很难，各种反动调的机制，给Reverse的同学添了不少麻烦。\n&ensp;&ensp;&ensp;&ensp;作为一名Misc手(?)，听说reverse题里居然有张图，当然要拿过来看一眼了。\n\n&ensp;&ensp;&ensp;&ensp;看起来很图片隐写啊！这样的图片也和几种隐写方法有点像。但既然是逆向题，应该不会用图片隐写的套路吧…\n&ensp;&ensp;&ensp;&ensp;先猜一下是什么隐写。尝试将图片旋转90度，用stegsolve打开，选择StereogramSolver，调整offset为1。\n\n&ensp;&ensp;&ensp;&ensp;居然真就直接出flag。给跪了。\norz orz orz orz orz orz orz orz orz orz orz orz orz orz orz orz orz orz orz orz orz orz orz orz orz orz orz orz orz orz orz orz orz orz orz orz orz orz orz orz orz orz orz orz orz orz orz orz orz orz orz orz orz orz orz orz orz orz orz orz orz orz orz orz orz orz orz orz orz orz orz orz orz orz orz orz orz orz orz orz orz orz orz orz orz orz orz orz orz orz orz orz orz orz orz orz orz orz orz orz \n","categories":["Writeup"],"tags":["CTF","Writeup"]},{"title":"Octane的moeCTF_2022 Writeup","url":"/posts/4/index.html","content":"OctaneのCTF初体验！\n准备在这里补（shui）一篇WP。因为题目数量挺多的，有些题目也是新手引导向的，或者仅仅涉及一些工具的基本使用方法，所以不会把所有的题目全都写一遍题解，还是主要写Crypto板块的一些题解。感觉有些题还是有记录一下的价值的，在复习的同时也可以把那些做题时没太深究的题深入研究一下。\nCrypto一次就好&ensp;&ensp;&ensp;&ensp;先看题目：\nfrom Crypto.Util.strxor import strxor\nfrom Crypto.Util.number import *\nfrom gmpy2 import powmod,next_prime\nfrom FLAG import flag\nimport codecs\n\nc = b'Just once,I will accompany you to see the world'\nflag = flag.ljust(len(c),'#')\nkey = strxor(flag.encode(), c)\nm = bytes_to_long(key)\n\np = getPrime(512)\nq = next_prime(p)\nN = p*q\ne = 0x10001\n\ngift = powmod(m, e, N)\n\nprint(gift)\nprint(N)\n\n# 输出略\n&ensp;&ensp;&ensp;&ensp;大概就是用一次性密码本加密flag，将key再用rsa加密。rsa加密时用的是相邻素数，因此用yafu很快就能分解N得到p和q然后解密出一次性密码本的key。再用该key和c进行异或就能得到flag。当时就是通过这道题了解到了yafu这个工具。\n&ensp;&ensp;&ensp;&ensp;解题脚本：\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\nfrom Crypto.Util.strxor import strxor\n\n#使用yafu.exe分解n得到pq\np = 12821668064849826676074701213910298504451620184307130249376361333490782040849300923713647818247010549622664747770828229853003308659470956068108542842690571\nq = 12821668064849826676074701213910298504451620184307130249376361333490782040849300923713647818247010549622664747770828229853003308659470956068108542842690393\ngift = 127749242340004016446001520961422059381052911692861305057396462507126566256652316418648339729479729456613704261614569202080544183416817827900318057127539938899577580150210279291202882125162360563285794285643498788533366420857232908632854569967831654923280152015070999912426044356353393293132914925252494215314\ne = 65537\nc = b'Just once,I will accompany you to see the world'\n\nd = gmpy2.invert(e, (p - 1) * (q - 1))\nm = pow(gift, d, p * q)\nflag = strxor(long_to_bytes(m), c)\nprint(flag)\n\n# moectf&#123;W0w_y02_k5ow_w6at_1s_one_t1m3_pa7&#125;######\n&ensp;&ensp;\n0rsa0&ensp;&ensp;&ensp;&ensp;题目：\nfrom Crypto.Util.number import *\nfrom flag import flag\n\nassert flag[0:7] == b'moectf&#123;'\nassert flag[-1:] == b'&#125;'\nflag = flag[7:-1]\nassert len(flag) == 32\n\nm1 = bytes_to_long(flag[0:16])\nm2 = bytes_to_long(flag[16:32])\n\ndef enc1(m):\n    p = getPrime(512)\n    q = getPrime(512)\n    n = p * q\n    e = 3\n    c = pow(m,e,n)\n    return n,e,c\n\ndef enc2(m):\n    p = getPrime(512)\n    q = getPrime(512)\n    e = 65537\n    d = inverse(e,(p-1)*(q-1))\n    n = p * q \n    dp2 = d % (p-1)\n    c = pow(m,e,n)\n    return n,e,c,dp2\n\nn1,e1,c1 = enc1(m1)\nn2,e2,c2,dp2 = enc2(m2)\n\nprint(\"n1=\"+ str(n1))\nprint(\"e1=\"+ str(e1))\nprint(\"c1=\"+ str(c1))\nprint(\"n2=\"+ str(n2))\nprint(\"e2=\"+ str(e2))\nprint(\"c2=\"+ str(c2))\nprint(\"dp2=\"+ str(dp2))\n\n# 输出略\n&ensp;&ensp;&ensp;&ensp;两个常见的rsa攻击套路。\n&ensp;&ensp;&ensp;&ensp;flag被分为两段分别加密。enc1是低指数小明文攻击。由于$e$比较小（只有3），明文的$e$次方仍然小于$n$，加密得到的$c=m^{e}$。因此将c直接开e次方即可得到flag。解题脚本如下：\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\nc1 = 1402983421957507617092580232325850324755110618998641078304840725502785669308938910491971922889485661674385555242824\ne1 = 3\n\nm = gmpy2.iroot(c1, 3)[0]\ncleartxt = long_to_bytes(m)\nprint(cleartxt)\n\n# T8uus_23jkjw_asr\n&ensp;&ensp;&ensp;&ensp;enc2是dp泄露攻击。\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\nn2 = 159054389158529397912052248500898471690131016887756654738868415880711791524038820158051782236121110394481656324333254185994103242391825337525378467922406901521793714621471618374673206963439266173586955520902823718942484039624752828390110673871132116507696336326760564857012559508160068814801483975094383392729\ne2 = 65537\nc2 = 37819867277367678387219893740454448327093874982803387661058084123080177731002392119369718466140559855145584144511271801362374042596420131167791821955469392938900319510220897100118141494412797730438963434604351102878410868789119825127662728307578251855605147607595591813395984880381435422467527232180612935306\ndp2 = 947639117873589776036311153850942192190143164329999603361788468962756751774397111913170053010412835033030478855001898886178148944512883446156861610917865\n\nfor i in range(1, e2):\n    p = (dp2 * e2 - 1) // i + 1\n    if n2 % p == 0:\n        q = n2 // p\n        print(p)\n        print(q)\n        break\n\nd = gmpy2.invert(e2, (p - 1) * (q - 1))\nm = pow(c2, d, p * q)\nprint(long_to_bytes(m))\n\n# _3d32awd!5f&amp;#@sd\n&ensp;&ensp;&ensp;&ensp;因此得到flag：\n\nmoectf{T8uus_23jkjw_asr_3d32awd!5f&amp;#@sd}\n\n&ensp;&ensp;\nWeird_E_Revenge&ensp;&ensp;&ensp;&ensp;先看题目：\nfrom Crypto.Util.number import *\nimport random\nfrom secret import flag\ntable='abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\npad=100-len(flag)\nfor i in range(pad):\n    flag+=random.choice(table).encode()\ne=343284449\nm=bytes_to_long(flag)\nassert m>(1&lt;&lt;512)\nassert m&lt;(1&lt;&lt;1024) \np=getPrime(512)\nq=getPrime(512)\nr=getPrime(512)\nprint('p=',p)\nprint('q=',q)\nprint('r=',r)\nn1=p*q\nn2=q*r\nc1=pow(m,e,n1)\nc2=pow(m,e,n2)\nprint('c1=',c1)\nprint('c2=',c2)\n\n# 输出略\n&ensp;&ensp;&ensp;&ensp;flag经过填充后分别用n1、n2加密，而n1、n2的因数p、q、r都是已知的，似乎解密需要的参数都是已知的。先尝试用RSA基本解密方法解。\nfrom gmpy2 import invert\nfrom Crypto.Util.number import long_to_bytes\nfrom libnum import solve_crt\n\ne = 343284449\np = 11820891196647569262137841192985418014377132106496147254821784946481523526822939129065042819464351666077658751406165276121125571355594004514547517855730743\nq = 10450390015864176713581330969519712299844487112687677452105216477861582967322473997670559995588440097951786576039009337782247912476227937589298529580432797\nr = 9484954066160968219229920429258150817546418633451929876581842443665029377287119340232501682142185708534413073877473741393278935479791561681402673403009771\nc1 = 69574855207460025252857869494766338442370688922127811393280455950372371842144946699073877876005649281006116543528211809466226185922844601714337317797534664683681334132261584497953105754257846471069875622054326463757746293958069752489458646460121725019594141157667480846709081917530190233900184428943585065316\nc2 = 66183492015178047844987766781469734325646160179923242098082430373061510938987908656007752256556018402101435698352339429316390909525615464024332856855411414576031970267795270882896721069952171988506477519737923165566896609181813523905810373359029413963666924039857159685161563252396502381297700252749204993228\n\nd = invert(e, (p-1)*(q-1))\nm1 = pow(c1, d, p*q)\nprint(long_to_bytes(m1))\n\n# Traceback (most recent call last):\n#   File \"solve_weirdrevenge.py\", line 12, in &lt;module>\n#     d = invert(e, (p-1)*(q-1))\n# ZeroDivisionError: invert() no inverse exists\n&ensp;&ensp;&ensp;&ensp;在解密过程中无法找到$e$关于$(p-1)(q-1)$或者关于$(q-1)(r-1)$的逆元。不能用基本方式解密。这是因为$e$与$(q-1)$不互素，从而与$(p-1)(q-1)$和$(q-1)(r-1)$都不互素，因此解不出逆元。但观察题目可以发现相同的明文由不同的n1、n2分别加密了两次。用同余式可以表示成这样：$$m^{e}\\ \\equiv\\ c_{1}\\ mod\\ n_{1}$$$$m^{e}\\ \\equiv\\ c_{2}\\ mod\\ n_{2}$$\n&ensp;&ensp;&ensp;&ensp;又$n_{1}=p\\cdot q$，$n_{2}=q\\cdot r$。由同余式的性质可以得到如下的同余方程式组：$$m^{e}\\ \\equiv\\ c_{1}\\ mod\\ p$$$$m^{e}\\ \\equiv\\ c_{2}\\ mod\\ r$$\n&ensp;&ensp;&ensp;&ensp;对于这样的同余方程式组，可以用中国剩余定理（CRT）求出一个与$m^{e}$等价的特解$x$。然后可以用$e$关于$(p-1)(r-1)$的逆元解密$x$得到明文，从而避开与$e$不互素的$(q-1)$。\n&ensp;&ensp;&ensp;&ensp;python的第三方库libnum有函数solve_crt可以直接调用。解题脚本如下：\nfrom gmpy2 import invert\nfrom Crypto.Util.number import long_to_bytes\nfrom libnum import solve_crt\n\ne = 343284449\np = 11820891196647569262137841192985418014377132106496147254821784946481523526822939129065042819464351666077658751406165276121125571355594004514547517855730743\nq = 10450390015864176713581330969519712299844487112687677452105216477861582967322473997670559995588440097951786576039009337782247912476227937589298529580432797\nr = 9484954066160968219229920429258150817546418633451929876581842443665029377287119340232501682142185708534413073877473741393278935479791561681402673403009771\nc1 = 69574855207460025252857869494766338442370688922127811393280455950372371842144946699073877876005649281006116543528211809466226185922844601714337317797534664683681334132261584497953105754257846471069875622054326463757746293958069752489458646460121725019594141157667480846709081917530190233900184428943585065316\nc2 = 66183492015178047844987766781469734325646160179923242098082430373061510938987908656007752256556018402101435698352339429316390909525615464024332856855411414576031970267795270882896721069952171988506477519737923165566896609181813523905810373359029413963666924039857159685161563252396502381297700252749204993228\n\nlist1 = [c1, c2]\nlist2 = [p, r]\nx = solve_crt(list1, list2)\nd = invert(e, (p - 1) * (r - 1))\nm = pow(x, d, p * r)\nprint(long_to_bytes(m))\n\n# moectf&#123;Th1s_iS_Chinese_rEm41nDeR_The0rEm_CRT!&#125;YWMZSTyfRvhjTCJuQCwALQBcWHFCgTDIZWJaxRUzBPCmFOnbDTRBau\n&ensp;&ensp;\nSignin&ensp;&ensp;&ensp;&ensp;题目：\nfrom Crypto.Util.number import *\nfrom secret import flag\nm=bytes_to_long(flag)\np=getPrime(512)\nq=getPrime(512)\nprint('p=',p)\nprint('q=',q)\nn=p*q\ne=65537\nc=pow(m,e,n)\nprint('c=',c)\n\n# 输出略\n&ensp;&ensp;&ensp;&ensp;虽然是签到题，但却在很长一段时间内一直都没做出来。后来才从在HNCTF上遇到的cot1007师傅学到了此类情况的做法。\n&ensp;&ensp;&ensp;&ensp;题目看起来很友好，加密用到的所有的数都直接给出来了。但$e$与$q-1$不互素，是无法用常规做法解出flag的。也不能像Weird_E_Revenge一样用中国剩余定理求解。\n&ensp;&ensp;&ensp;&ensp;实际上解法很简单。虽然$e$与$q-1$不互素，但其实$m&lt;p$。因此可以直接将$c\\ mod\\ p$，将问题变为$m^{e}\\ \\equiv\\ c’\\ mod\\ p$，绕过有问题的$q$。解题脚本：\nfrom Crypto.Util.number import long_to_bytes\nfrom gmpy2 import invert\n\ne = 65537\np= 12408795636519868275579286477747181009018504169827579387457997229774738126230652970860811085539129972962189443268046963335610845404214331426857155412988073\nq= 12190036856294802286447270376342375357864587534233715766210874702670724440751066267168907565322961270655972226761426182258587581206888580394726683112820379\nc= 68960610962019321576894097705679955071402844421318149418040507036722717269530195000135979777852568744281930839319120003106023209276898286482202725287026853925179071583797231099755287410760748104635674307266042492611618076506037004587354018148812584502385622631122387857218023049204722123597067641896169655595\n\nc1 = c%p\nphi = p-1\nd = invert(e, phi)\nm = pow(c1, d, p)\n\nprint(long_to_bytes(m))\n\n# moectf&#123;Oh~Now_Y0u_Kn0W_HoW_RsA_W0rkS!&#125;\n&ensp;&ensp;\n\n&ensp;&ensp;&ensp;&ensp;下面几道题先把自己的解题脚本贴在这，解题思路以后一定补完（\n\nSmooth&ensp;&ensp;&ensp;&ensp;解题脚本：\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\nc = int(\n    '0x3cc51d09c48948e2485820f6758fb10c7693c236acc527ad563ba8369c50a0bc3f650f39a871ee7ef127950ed916c5f4dc69894e11caf9d178cd7e8f9bf9af77e1c69384cc5444da64022b45636eeb5b7a221792880dd242be2bb99be3ed02c430c2b77d4912bec1619d664e066680910317c2bb0c87fafdf25f0a2400103278f557b8eca51d3b67d61098f1ab68da072bb2810596180afbc81a840cd24efef4d4113235160e725a5af4824dc716d758b3bc792f2458e979398e001b27e44d21682e2ef80ae94e21cd09a12e522ca2e569df72f012fa40341645445c6e68c6233a8a39e5b91eb14b1ccfa61c9bad25e8e3285a22da27cd506ddd63f207517a4e8ede00b104d8806ff4c0e3162c3de69169d7e584952655272b96d39d242bb83019c7eab1ceb0b4b287591e1e0a5b6378e70340a82d3430c5925d215f31fda6d9d0bccea240591b22a3d0f6b5bf4ddf1243d71aca0fd53045c352c8c5497ebcdbd7ac11083d63aba7c053604fda2430c317a4e04702b5ad539e110f101165b21dcd9fdb5ba7324acdba6a506244ce7c911197dfe067441fe7488d164c050f45ef6476aaf399cedde1793cceb8c21d88ec8ecf5e17df27586713d7dd9566ec5023cfef75422b73e2d5a932c661b3cfdf9c4bda12b64380d2be1aa957c3e1416e068937bafe79b8cf303296792388e9c197702e11e7ded6088ae992d352b23a4a27',\n    16)\nN = int(\n    '0xdc77f076092cbe81c44789ccfc1b2ca55eabae65f44cf34382799e8bbb42d4d6c032bd897c21df1da401929d82deb56264823a757f6cacf63e0037146026cbab32ab9e4abc783dcabaac2b7ccc439937be3ab0fbf149524ff29ef0fe6f27e45215d74b40597c70e8207159dc7f542c2a6828500016480053dfc2d8dbf8fcdf6700640184c8f3318f7aab2e17e116edf680592f5eae951159bb8c20cfbd0cbab8b4b95925b5068038d0377a55a4d346ebbf53a1c2943b7c17e1b9d4a1b77916da2e15140b05b96655906942a07d04b7e25fa7521b3b7ae26eda68375a8b8ef2d5b4704a28168b236de97f24a663f0d0a3aeab47767dfe75a21662f5f25ef7f7d4b25c90fd7bcdd7137c23f03b6ea4209f8fb9b4628355e6ad62e6467d26666d3d1b0e6f078c5f3866413a6fcd3c1dc2ff3a5ab286e339d5c72f4d2f0473a4faddcba6b031bb6ec226fd4b319834b5029f09ea0ffeb5b6ed182d5a13675571b6708c38299118043390343e2f79edebd2ae0e0a765a3aebf776f54ca983cdae8547547cfc8430f7222aefa77301d7cc7c03b1451b6603028b21fea869d35138a9c83919985a91b3fdfa934f25a442cc10349b0ed6f2ee3955d40249e8b3fb9f1955534ee06cee41a3ad2d6ff7dbdb0f01e47b9e4d04f65232f5579135ae035e8ba2d1fe6465a730dcc8b9ba3a558ab38f040ea510757d25e92f886c50c24ad967f1',\n    16)\n\ndef Pollards_p_1(N): # Pollards 光滑数算法\n    a = 2\n    n = 1\n    while True:\n        a = pow(a, n, N)\n        res = gmpy2.gcd(a - 1, N)\n        if res != 1 and res != N:\n            return res\n        n += 1\n\ne = 65537\np = Pollards_p_1(N)\nq = N // p\nd = gmpy2.invert(e, (p - 1) * (q - 1))\nm = pow(c, d, N)\n\nfor i in range(2, 1730): # 根据同余式的性质和Wilson定理推导\n    m *= (p - i)\ncleartxt = m % p\n\nprint(long_to_bytes(cleartxt))\n\n# moectf&#123;Charming_primes!_But_Sm0oth_p-1_1s_vu1nerab1e!&#125;\n&ensp;&ensp;\nezcbc&ensp;&ensp;&ensp;&ensp;解题脚本：\nfrom Crypto.Util.number import *\n\nc0 = 748044282\nc = [748044282, 2053864743, 734492413, 675117672, 1691099828, 1729574447, 1691102180, 657669994, 1741780405, 842228028, 1909206003, 1797919307]\n\nIV = bytes_to_long(b'cbc!')\ncleartxt0 = b'moec'\ncleartxt = []\n\ncleartxt.append(cleartxt0.decode('utf8', 'ignore'))\nk = IV ^ bytes_to_long(cleartxt0) ^ c0\n\nfor i in range(len(c) - 1):\n    txt = long_to_bytes((k ^ c[i + 1] ^ c[i]))\n    cleartxt.append(txt.decode('utf8', 'ignore'))\nprint(cleartxt)\n\n# moectf&#123;es72b!a5-njad!@-#!@$sad-6bysgwy-1adsw8&#125;\n&ensp;&ensp;\nezhash&ensp;&ensp;\nbabyNETpart1&ensp;&ensp;&ensp;&ensp;解题脚本：\nfrom Crypto.Util.number import long_to_bytes\nfrom Crypto.Util.number import bytes_to_long\nfrom Crypto.Cipher import AES\n\ndef encrypt(plaintext, key):\n    assert len(plaintext) == 32\n    assert len(key) == 16\n\n    left = plaintext[:16]\n    right = plaintext[16:]\n\n    for i in range(3):\n        aes = AES.new(key, AES.MODE_ECB)\n        new_right = long_to_bytes(\n            bytes_to_long(aes.encrypt(right)) ^ bytes_to_long(left))\n        new_left = right\n        left = new_left\n        right = new_right\n    return left + right\n\n\ndef decrypt(ciphertext, key):\n    assert len(ciphertext) == 32\n    assert len(key) == 16\n\n    left = ciphertext[:16]\n    right = ciphertext[16:]\n\n    for i in range(3):\n        aes = AES.new(key, AES.MODE_ECB)\n        last_right = left\n        last_left = long_to_bytes(\n            bytes_to_long(right) ^ bytes_to_long(aes.encrypt(left)))\n        left = last_left\n        right = last_right\n    return left + right\n\n\nkey1 = b'this_is_the_key~'\nkey2 = b'to_enlength_key!'\ncipher = long_to_bytes(\n    int(0x8b6d863f3e89fd2698ff90e8409502ebf485e17449cdaceb6f5cb2e781524ce4))\n\ndecipher = decrypt(cipher, key1)\ndecipher = encrypt(decipher, key2)\ndecipher = decrypt(decipher, key1)\nprint(decipher)\n\n# b'it_is_just_the_fy0u_can_d0_what?'\npart2&ensp;&ensp;&ensp;&ensp;解题脚本：\nfrom Crypto.Util.number import long_to_bytes\nfrom Crypto.Cipher import AES\n\nclass AES_CBC(object):\n\n    def __init__(self, key, iv):\n        self.key = key\n        self.mode = AES.MODE_CBC\n        self.iv = iv\n\n    def pad_byte(self, b):\n        bytes_num_to_pad = AES.block_size - (len(b) % AES.block_size)\n        return b + bytes([bytes_num_to_pad]) * bytes_num_to_pad\n\n    def encrypt(self, text):\n        cryptor = AES.new(self.key, self.mode, self.iv)\n        text = self.pad_byte(text)\n        self.ciphertext = cryptor.encrypt(text)\n        return self.ciphertext\n\n    def decrypt(self, text):\n        unpad = lambda s: s[:-ord(s[len(s) - 1:])]\n        cryptor = AES.new(self.key, self.mode, self.iv)\n        aesStr = cryptor.decrypt(text)\n        aesStr = str(unpad(aesStr), encoding='utf8')\n        return aesStr\n\nencdata = long_to_bytes(int(0x1fe9c9b13b8af4f59857d9bc5df1bfbc9df34b8a4a33455b244fb0d857f98c3ea8a62b0190e7336dde76365e65e955c4))\nK = b'it_is_just_the_f'\nIV = b'y0u_can_d0_what?'\npc = AES_CBC(K, IV)\ndata = pc.decrypt(encdata)\nprint(data)\n\n# Congratulations!_You_have_get_the_flag!\n&ensp;&ensp;\nMiniMiniBackpack&ensp;&ensp;&ensp;&ensp;解题脚本：\nfrom Crypto.Util.number import long_to_bytes\n\nkey = [......] # 输入略\nc = ......\n\nL = len(key)\ncleartxt = []\nv1 = c\n\nfor i in range(L):\n    if v1 - key[-1 - i] &lt; 0:\n        v1 -= 1\n        cleartxt.append(0)\n    if v1 - key[-1 - i] >= 0:\n        v1 -= key[-1 - i]\n        cleartxt.append(1)\n        \nprint(long_to_bytes(int(''.join(map(str, cleartxt)),2)))\n\n# moectf&#123;Co#gRa7u1at1o^s_yOu_c6n_d3c0de_1t&#125;\n&ensp;&ensp;\n不止一次&ensp;&ensp;\nMiscHamming&ensp;&ensp;&ensp;&ensp;解题脚本：\nnoisemsg = [......] # 输入略\nflag = '0'\n\nfor i in range(len(noisemsg)):\n    tmp = noisemsg[i]\n\n    check1mem = 0\n    check1 = [\n        tmp[1], tmp[3], tmp[5], tmp[7], tmp[9], tmp[11], tmp[13],\n        tmp[15]\n    ]\n    if check1.count(1) % 2 == 0:\n        pass\n    else:\n        check1mem = 1\n\n    check2mem = 0\n    check2 = [\n        tmp[2], tmp[3], tmp[6], tmp[7], tmp[10], tmp[11], tmp[14],\n        tmp[15]\n    ]\n    if check2.count(1) % 2 == 0:\n        pass\n    else:\n        check2mem = 1\n\n    check3mem = 0\n    check3 = [\n        tmp[4], tmp[5], tmp[6], tmp[7], tmp[12], tmp[13], tmp[14],\n        tmp[15]\n    ]\n    if check3.count(1) % 2 == 0:\n        pass\n    else:\n        check3mem = 1\n\n    check4mem = 0\n    check4 = [\n        tmp[8], tmp[9], tmp[10], tmp[11], tmp[12], tmp[13], tmp[14],\n        tmp[15]\n    ]\n    if check4.count(1) % 2 == 0:\n        pass\n    else:\n        check4mem = 1\n\n    check0mem = [check1mem, check2mem, check3mem, check4mem]\n\n    if check4mem == 1:\n        if check3mem == 1:\n            if check2mem == 1:\n                if check1mem == 1:\n                    errorplace = 15\n                else:\n                    errorplace = 14\n            else:  #c2==0\n                if check1mem == 1:\n                    errorplace = 13\n                else:\n                    errorplace = 12\n        else:  #c3==0\n            if check2mem == 1:\n                if check1mem == 1:\n                    errorplace = 11\n                else:\n                    errorplace = 10\n            else:  #c3==0\n                if check1mem == 1:\n                    errorplace = 9\n                else:\n                    errorplace = 8\n    else:  #c4==0\n        if check3mem == 1:\n            if check2mem == 1:\n                if check1mem == 1:\n                    errorplace = 7\n                else:\n                    errorplace = 6\n            else:  #c2==0\n                if check1mem == 1:\n                    errorplace = 5\n                else:\n                    errorplace = 4\n        else:  #c3==0\n            if check2mem == 1:\n                if check1mem == 1:\n                    errorplace = 3\n                else:\n                    errorplace = 2\n            else:  #c2=0\n                if check1mem == 1:\n                    errorplace = 1\n                else:\n                    errorplace = 0\n\n    if tmp[errorplace] == 1:\n        tmp[errorplace] = 0\n    elif tmp[errorplace] == 0:\n        tmp[errorplace] = 1\n\n    cleartxt = [\n        tmp[3], tmp[5], tmp[6], tmp[7], tmp[9], tmp[10], tmp[11],\n        tmp[12], tmp[13], tmp[14], tmp[15]\n    ]\n\n    for k in range(len(cleartxt)):\n        cleartxt[k] = str(cleartxt[k])\n\n    flag+=''.join(cleartxt)\n\ncleartxt = ''\nfor i in range(len(flag)//8):\n    cleartxt += chr(int(flag[8*i:8*i+8], 2))\nprint(cleartxt)\n\n# Once upon a time, there were 1023 identical bottles, 1022 of which were plain water and one of which was poison. Any creature that drinks the poison will die within a week. Now, with 10 mice and a week, how do you tell which bottle has poison in it?\n# moectf&#123;Oh_Bin4ry_Mag1c_1s_s0o_c0O1!&#125; Great!\n&ensp;&ensp;\n","categories":["Writeup"],"tags":["CTF","Writeup"]},{"title":"Octane的TSCTF-J Writeup","url":"/posts/3/index.html","content":"比赛前早早地注册了Octane的比赛ID，但比赛开始时居然忘了密码，于是只能临时注册了一个Nonane的ID来打orz\n最后拿了个总榜第十一，领到了奖品。同时也学到了很多，看到了自己很多的不足和以后该努力的方向。\n这次比赛主要做的是Crypto和MISC。感觉套路题比较少，至少很无脑的套路不多。比赛前做了一些RSA的简单套路，积累了一点解题脚本，本以为能多水两道，但做比赛才发现Crypto出题人把套路全都放在放在第一道题上了（虽然Padding也是套路题，但到比赛结束也还是没整出来orz）。剩下几道完全是数学题，因为智商不够而被薄纱orz\nMisc的各种图片隐写和压缩包隐写的题型是一道也没考（之前看了去年的隐写题还有点期待今年的来着）。和编码有关的题还出在了Crypto板块中。虽然说隐写题只是和出题人对电波而已…但感觉Black_Tea才是更电波的啊，没见过这种问题就完全没有头绪，上网搜都不知道该搜什么orz。Misc的游戏题确实挺好玩的，也辛苦游戏制作者了。\n比赛题目存档和官方wp：https://github.com/MakeMerakGreatAgain/tsctf-j_2022\nReverseBaby_xor&ensp;&ensp;&ensp;&ensp;签到题,放进IDA里直接F5，可以看到代码。\n\n&ensp;&ensp;&ensp;&ensp;数组data[ ]中每个元素分别与i和0x46进行异或运算即可得到flag\n&ensp;&ensp;&ensp;&ensp;解题脚本：\ndata = [......] # 输入略\nfor i in range(len(data)):\nout.append(chr(i^data[i]^70))\nprint(''.join(out))\n\n# TSCTF-J&#123;W3lC0M3_2_ReVEr$E^xOr_1s_$O0o_e2&#125;\n&ensp;&ensp;\nByte_code&ensp;&ensp;&ensp;&ensp;题目给了一个txt文件，打开后是这样的代码：\n\n&ensp;&ensp;&ensp;&ensp;上网查了一下，这个是Python的字节码。用python -m dis命令即可将py文件转换为字节码。原来想找一个可以将字节码直接转换回py文件的程序，但代码看起来并没有很长，就干脆直接自己对照着字节码写出python代码，每写一行就编译成字节码和原文件对照。最后还原出来的python脚本是这样的，再运行一下就可以得到flag。\na=[114, 101, 118,101,114,115,101,95,116,104,101,95,98,121,116,101]\nb=[99,111,100,101,95,116,111,95,103,101,116,95,102,108,97,103]\ne=[80,115,193,24,226,237,202,212,126,46,205,208,215,135,228,199,63,159,117,52,254,247,0,133,163,248,47,115,109,248,236,68]\npos=[9,6,15,10,1,0,11,7,4,12,5,3,8,2,14,13]\nd=[335833164, 1155265242, 627920619, 1951749419, 1931742276, 856821608, 489891514, 366025591, 1256805508, 1106091325, 128288025, 234430359, 314915121, 249627427, 207058976, 1573143998, 1443233295, 245654538, 1628003955, 220633541, 1412601456, 1029130440, 1556565611, 1644777223, 853364248, 58316711, 734735924, 1745226113, 1441619500, 1426836945, 500084794, 1534413607]\nc=a+b\nfor i in range(31):\n    print(chr(c[i]), end='')\nfor i in range(16):\n    a[i]=a[i]+d[i]^b[pos[i]]\nfor i in range(16):\n    b[i]=b[i]^a[pos[i]]\nc=a+b\nfor i in range(32):\n    c[i]=c[i]*d[i]%256\n    c[i]^=e[i]# 18\n    print(chr(c[i]), end='')\n\n# TSCTF-J&#123;bY7ecoDe_I$_nOT_so_HArd&#125;\n&ensp;&ensp;\nCrypto锟斤拷烫烫烫&ensp;&ensp;&ensp;&ensp;查看题目：\n烫烫烫锟斤拷&#x2F;烫烫烫锟斤拷锟斤拷锟斤拷&#x2F;烫烫烫锟斤拷锟斤拷烫烫烫&#x2F;烫烫烫锟斤拷锟斤拷烫烫烫&#x2F;烫烫烫锟斤拷烫烫烫&#x2F;烫烫烫烫烫烫锟斤拷锟斤拷&#x2F;烫烫烫锟斤拷锟斤拷&#x2F;锟斤拷锟斤拷烫烫烫锟斤拷&#x2F;烫烫烫烫烫烫&#x2F;锟斤拷烫烫烫烫烫烫烫烫烫&#x2F;烫烫烫锟斤拷锟斤拷烫烫烫&#x2F;烫烫烫锟斤拷锟斤拷烫烫烫&#x2F;烫烫烫烫烫烫锟斤拷烫烫烫&#x2F;锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷&#x2F;锟斤拷烫烫烫锟斤拷锟斤拷&#x2F;锟斤拷锟斤拷烫烫烫锟斤拷&#x2F;烫烫烫锟斤拷&#x2F;锟斤拷烫烫烫烫烫烫烫烫烫&#x2F;锟斤拷锟斤拷烫烫烫&#x2F;锟斤拷烫烫烫烫烫烫&#x2F;锟斤拷锟斤拷锟斤拷锟斤拷烫烫烫&#x2F;烫烫烫烫烫烫锟斤拷锟斤拷&#x2F;锟斤拷锟斤拷锟斤拷烫烫烫烫烫烫&#x2F;烫烫烫烫烫烫锟斤拷锟斤拷&#x2F;烫烫烫烫烫烫&#x2F;锟斤拷锟斤拷锟斤拷烫烫烫&#x2F;锟斤拷烫烫烫烫烫烫&#x2F;烫烫烫烫烫烫锟斤拷&#x2F;烫烫烫锟斤拷烫烫烫&#x2F;锟斤拷锟斤拷锟斤拷锟斤拷烫烫烫&#x2F;锟斤拷烫烫烫锟斤拷锟斤拷&#x2F;锟斤拷锟斤拷锟斤拷烫烫烫&#x2F;烫烫烫锟斤拷&#x2F;烫烫烫锟斤拷烫烫烫烫烫烫&#x2F;烫烫烫锟斤拷锟斤拷锟斤拷烫烫烫&#x2F;烫烫烫锟斤拷锟斤拷锟斤拷烫烫烫&#x2F;烫烫烫锟斤拷锟斤拷锟斤拷烫烫烫&#x2F;烫烫烫锟斤拷锟斤拷锟斤拷烫烫烫&#x2F;烫烫烫锟斤拷锟斤拷锟斤拷烫烫烫&#x2F;烫烫烫锟斤拷锟斤拷锟斤拷烫烫烫\n&ensp;&ensp;&ensp;&ensp;虽然”锟斤拷烫烫烫”是一种众所周知的中文乱码，但这种乱码已经丢失了原本的数据，是不能还原出原始信息的！因此这道题不可能是真的”锟斤拷烫烫烫”乱码，而是隐藏着某种别的加密或编码方式。\n&ensp;&ensp;&ensp;&ensp;观察文本内容很容易发现，文段只由”锟斤拷”和”烫烫烫”和斜杠组成。由此很容易想到摩斯电码。\n&ensp;&ensp;&ensp;&ensp;用记事本的替换功能，将”锟斤拷”替换成”.”，将”烫烫烫”替换成”-“，以摩斯电码翻译，得到一串字符：\n\nnbxxkzdfmjxxq5lfnjuw4z3zmvwgk4lvny======\n\n&ensp;&ensp;&ensp;&ensp;观察字符很容易发现，字符尾部有数个等号，并且只有小写字母和数字（因为摩斯电码本身不区分大小写）。很明显是base32编码。将小写字母全部替换为大写字母，进行base32解码，得到柏油校训的拼音，即是flag：\n\nTSCTF-J{houdeboxuejingyelequn}\n\n&ensp;&ensp;\nT0ni’s RSA&ensp;&ensp;&ensp;&ensp;查看题目：\nfrom Crypto.Util.number import *\nfrom gmpy2 import *\nfrom secret import flag\n\nassert len(flag)==48\nflag1=flag[0:12]\nflag2=flag[12:24]\nflag3=flag[24:36]\nflag4=flag[36:48]\n\nprint(\"=====================================flag1\")\nm=bytes_to_long(flag1)\np=getPrime(1024)\nq=getPrime(1024)\ne=65537\nn=p*q\nc=powmod(m,e,n)\nprint(\"p =\",p)\nprint(\"q =\",q)\nprint(\"e =\",e)\nprint(\"c =\",c)\n\nprint(\"=====================================flag2\")\nm=bytes_to_long(flag2)\np=getPrime(64)\nq=getPrime(64)\ne=65537\nn=p*q\nc=powmod(m,e,n)\nprint(\"n =\",n)\nprint(\"e =\",e)\nprint(\"c =\",c)\n\nprint(\"=====================================flag3\")\nm=bytes_to_long(flag3)\np=getPrime(1024)\nq=next_prime(p)\ne=65537\nn=p*q\nc=powmod(m,e,n)\nprint(\"n =\",n)\nprint(\"e =\",e)\nprint(\"c =\",c)\n\nprint(\"=====================================flag4\")\nm=bytes_to_long(flag4)\np=getPrime(1024)\nq=getPrime(1024)\ne=7\nn=p*q\nc=powmod(m,e,n)\nprint(\"n =\",n)\nprint(\"e =\",e)\nprint(\"c =\",c)\n\n# 输出略\n&ensp;&ensp;&ensp;&ensp;由题目可知flag分为四段，分别加密四次，根据每次加密的方式分别解密即可得到flag\n&ensp;&ensp;&ensp;&ensp;解题脚本：\nfrom Crypto.Util.number import long_to_bytes\nfrom gmpy2 import iroot, invert\n\ndef rsa_decrypt(p:int, q:int, e:int, c:int):\n    d = invert(e, (p-1)*(q-1))\n    m = pow(c, d, p*q)\n    return m\n\n# flag1:pq已知，直接用基本方法解密\np0 = 126848068662434725837362927110508359670513097902158347608742478683379412542373205396355795471254038301102414856525121647188484976552142343067044591036870463204973197337043645689668460536955381260032883948287738855267140030987485450026217231376934834164731323791161242646800219869703713605170682364116602398481\nq0 = 108831434115512090318037589335170063989256445400295000303568098461799570376658935415095544400164386313684432766346946165811277996284801631673216470358009654117077854125122927553974223129029217160157869796055967783796164293604324171269850795257143703187899358858675646672321319018167474020363026585548820771697\ne0 = 65537\nc0 = 12806426835071949867711416962709958594314368469792264574105984900555439512183487926101898057954900183669492820478219013019317212504718045553210233002824678962092820191899047884098185828625477721152790480535997733511787559909800255732856472382084502459064555276405636335011653299264667296955585832665754137638936306114164795630686750776282273654483469063781121080308493239356585954141139584326117462247270605137016151223704623131634401478066683053816761883398796060573577823014077050991745590269109018594293646949390055766822956018083267147781811450534232319486801350308073725708881185484667042111239958769639753074974\nm0 = long_to_bytes(rsa_decrypt(p0, q0, e0, c0))\n\n# flag2:p和q都比较小，可以直接用yafu分解n，得到p1和p2，再解密\np1 = 10044079891992334031\nq1 = 11695298459661145481\ne1 = 65537\nc1 = 116661533228458434140621528983098975679\nm1 = long_to_bytes(rsa_decrypt(p1, q1, e1, c1))\n\n# flag3:p和q是相邻质数，也能很容易用yafu分解n得到pq\nq2 = 116157631074161326668152038927249334338399827206586914589176832177082944299227717473355044107614652079152523161147120835537353552449908708629934368874677505050900078018992526314964561246045453416854196152086105218778204572329269076361235953745958869643828443636138454981800813514293034142691705140488032064827\np2 = 116157631074161326668152038927249334338399827206586914589176832177082944299227717473355044107614652079152523161147120835537353552449908708629934368874677505050900078018992526314964561246045453416854196152086105218778204572329269076361235953745958869643828443636138454981800813514293034142691705140488032060333\ne2 = 65537\nc2 = 9556855627975459046740821834528544070427049621127160951742003478725424449033433009828717934730280978533743220944726870403563278379897696996593408941742726761954126312142544881536075456011232335038713394388844246035946642298588354835538957640121051986433171003548328013363624428388045689223434747553158248457199579326477645217581943607544640937724609291757178063476167129106555047385785925998650584941948353305651394629383203202173799027705269424908549510903196317581322985993424298619576745664607011471390391051884932663025002185768778902167735501719300645089512150938345539777564021221129832163135987500087303945958\nm2 = long_to_bytes(rsa_decrypt(p2, q2, e2, c2))\n\n# flag4:低指数小明文攻击，直接将c开e次方即可\ne3 = 7\nc = 24352183908812439486066187971806232095447207924326195067955513727448051350160252184726311366048048945796542616778567176778473328388848916602914602254361942853429047133399539108358587787495587158203125\nm3 = long_to_bytes(iroot(c, 7)[0])\nprint(m0 + m1 + m2 + m3)\n\n# TSCTF-J&#123;T0niii_is_the_most_handsome_boy_in_BUPT&#125;\n&ensp;&ensp;\nNonograms\n&ensp;&ensp;&ensp;&ensp;似乎是某种填字游戏，总共14张图。曾经在steam玩过玩法类似的SquareCells。\n&ensp;&ensp;&ensp;&ensp;hint提示用画图的填充工具做，本想找到一个可以在线解密的网站。但最后还是自己做了。\n&ensp;&ensp;&ensp;&ensp;先在前几个挑了几个简单的做，得到这个\n\n&ensp;&ensp;&ensp;&ensp;由此可知前8个图是’TSCTF-J{‘。最后一个图是’}’。因此中间9-13五张图才是flag的实际内容。\n\n&ensp;&ensp;&ensp;&ensp;由此很容易可以猜测出flag：\n\nTSCTF-J{旗开得勝！}\n\n&ensp;&ensp;\nTwo Keys\n&ensp;&ensp;&ensp;&ensp;由题目描述可知flag分为两段，分别用key和KEY加密。\n&ensp;&ensp;&ensp;&ensp;第一段flag用RSA加密，p、q、phi都是已知的，而e就是key，即是Question1的答案。\n\n&ensp;&ensp;&ensp;&ensp;询问出题人这个问题的具体规则，得知不能走回头路，整个过程只能网上或往右走。\n&ensp;&ensp;&ensp;&ensp;虽然不会算这种问题，但可以估计最终的答案不会非常大。能爆破的题为什么还要动脑算？\n&ensp;&ensp;&ensp;&ensp;于是写一个脚本直接爆破e解密，从而得到第一段flag。\nfrom gmpy2 import invert\nfrom Crypto.Util.number import long_to_bytes\n\nn = int('7a9a4979dd59cd8b38706b0920ffc1d63ee9c6c94cc6bf097c0957d5017b6562d7b03f396b9cd1f9e6a7303522effe632422c44360c66fe8526ff997db1496f2c1a70ab179f59f5fc4b1dd5513cc663d811b50e1c2b29dfa1ae5228b1fd2b7b65595c4486eb3d22fbd2b6fba58b4f299f07a73fc90e97af9781156afb0af32a02a4a1198b734fa2fefdfd64d2767e095db30919a6cbf3de0217f949d9b46e704a3cefe3af62fdfdd702e439ef423e7582d6b67903a1c956d1d7f3a62baa217f2c47d81c08f9734eb19f13c9bcd3d55c098498af02aa4dc5449668682a150050675d0b74e9dfb2698031dcbd726da450c62f48a4b24ab2da2d8bd2b1421000361', 16)\nphi = int('7a9a4979dd59cd8b38706b0920ffc1d63ee9c6c94cc6bf097c0957d5017b6562d7b03f396b9cd1f9e6a7303522effe632422c44360c66fe8526ff997db1496f2c1a70ab179f59f5fc4b1dd5513cc663d811b50e1c2b29dfa1ae5228b1fd2b7b65595c4486eb3d22fbd2b6fba58b4f299f07a73fc90e97af9781156afb0af329ec7f057b665e05893cc0d6c79028fb4786e44d66c74dd79a180ad035f8de4256d8b988038fa097a526dcc55678d80cf651b40965b08ee40d2c733220bd6fbdaebd13175d04a1498c16436f93e8d441f74d1ed77eecb9866f0c02a07c1bc1021d4329c2d8211f3e60f8bfc409c5a7424cfb7dc5d7f97a932f9eb303741bb9312c0', 16)\nc = int('57765d8a8d0d74a3f6e3151cc1276b8db6e790d691f7d06713c1d5791164902f6add5a4350512225034d114ae59603a431d1b8ebc956bdc30a3d69cc364649dada23153483bfbf1cfb06ffb22ca9e969674d68a2dae6c9482dfe7b95561035396996473d37cdae2c7e6bda62face36d487d31810cad3382a37c881ea694eb45b4a1788eb1f7865ff3105a3669e7bf39bb0e04d46b98acbfefbdebeb3c2e967e1db553420337db750805d08483760f7abb9ad69d4fc489ec3c2cc9c10778fe03090b8b0b33854047aafab676c4a2a4d6b94b4df6e2ed6f23d9ba6e8713cbeeb5aab5bbf23558afade67460d2561f0a60a26a8c064550eb858b8e25fcf72bcb581', 16)\n\ne = 1\nwhile True:\n    try:\n        d = invert(e, phi)\n        m = pow(c, d, n)\n        out = long_to_bytes(m)\n        print(str(out.decode('utf-8', 'strict')))\n        break\n    except:\n        e += 1\n        continue\n\n# TSCTF-J&#123;C0mbinAt0rial_M4themat1cs_aNd_\n&ensp;&ensp;&ensp;&ensp;Qustion2：\nprint(\"Question 2:\\n\\nKEY is a string of 8 lowercase letter.\\n\\nsha256(KEY) == 2b87ea3983c646fcecc476f6930c18bf75935cab40471930f560bef2f370b82e and len(KEY) == 8\\n\")\n&ensp;&ensp;&ensp;&ensp;第二段flag用DES加密，密钥KEY就是Question2的答案。Question2给出了KEY的sha256哈希值，并且已知KEY由八个小写英文字母组成。于是用hashcat进行哈希碰撞得到KEY：\n\n&ensp;&ensp;&ensp;&ensp;很快就可以解出KEY是’vmefifty’。用KEY解密DES密文即可得到第二段flag：\nfrom Crypto.Cipher import DES\n\ncipher2 = b'\\x83\\xce\\x8a\\xdac)\\xd2\\xa41\\xe26\\xd5\\x12\\xcf\\x9aV;%\\x80\\xc1\\x87\\x97\\xe0\\xc3\\x03\\x17\\xfeR\\x97b\\x86\\xf9\"\\x1c\\xde\\xf4\\xc1F\\xd5\\x13\\x1e$\\xc3\\xb8\\x84Z&#125;\\xac'\nKEY = b'vmefifty' # 由hashcat得到的KEY\n\ngenerator = DES.new(KEY, DES.MODE_ECB)\nprint(generator.decrypt(cipher2))\n\n# Ha$h-Alg0rithms_aRe_1mportaNt_in_CryptOgraphy&#125;\n&ensp;&ensp;&ensp;&ensp;最终得到完整flag：\n\nTSCTF-J{C0mbinAt0rial_M4themat1cs_aNd_Ha$h-Alg0rithms_aRe_1mportaNt_in_CryptOgraphy}\n\n&ensp;&ensp;\nT0ni’s Encode&ensp;&ensp;&ensp;&ensp;查看题目：\nfrom Crypto.Util.number import *\nfrom secret import flag,key\n\ndata=b'abcdefghijkl0123456789'\nfor i in range(len(key)):\n    assert key[i] in data\n\ndef T0nihash(a,b):\n    if(bytes_to_long(b+a)!=0):\n        return long_to_bytes((bytes_to_long(a)*bytes_to_long(a+b))%bytes_to_long(b+a))\n    else:\n        return b'hahahahaha'\n\nhint=b'thisishint'\ncipher=b''\nassert flag[0:10]==b'TSCTF-J&#123;Ba'\n\nfor i in range(len(flag)//5):\n    tmp=flag[5*i:5*i+5]\n    if(sum(tmp)%2==0):\n        cipher+=long_to_bytes(bytes_to_long(tmp)^bytes_to_long(key[0:5]))\n        key=T0nihash(key[0:5],key[5:10])\n        hint=T0nihash(hint[0:5], hint[5:10])\n    else:\n        cipher+=long_to_bytes(bytes_to_long(tmp)^bytes_to_long(key[5:10]))\n        key=T0nihash(key[5:10],key[0:5])\n        hint=T0nihash(hint[5:10], hint[0:5])\n\nprint(\"cipher =\",cipher)\nprint(\"hint =\",hint)\n\n# 输出略\n&ensp;&ensp;&ensp;&ensp;分析题目，首先已知’key’中的字符一定在’data’里，即一定是小写字母和数字。并且题目给出了明文即flag的前十个字符’TSCTF-J{Ba’。\n&ensp;&ensp;&ensp;&ensp;分析加密过程，首先题目将flag明文按每五个字符分为一组，分组进行加密。每一组的明文的sum如果能被2整除，该组明文与key的前五位进行异或运算；当明文的sum不能被2整除时，明文与key的后五位进行异或运算。两种情况都在加密后用’T0nihash’函数对key进行一次变换，并且变换时key的前五位和后五位的前后顺序不同，以使得每一组加密时使用的密钥都互不相同。\n&ensp;&ensp;&ensp;&ensp;从加密过程可以得知，加密前后各组数据的顺序和大小都没有改变，密文的第n位一定对应明文的第n位。而每一次加密的步骤用的是可逆得到异或运算。我们已知前两组加密使用的明文分别是’TSCTF’和’-J{BA’，因此很容易求出加密前两组使用的密钥。由于解密和加密的顺序系统，解密时密钥的变换方式与加密时相同，因此我们只要知道初始密钥，再按与加密相同的步骤依次进行异或运算即可得到明文。\n&ensp;&ensp;&ensp;&ensp;首先分别求出前两组明文的sum，以判定它们时以key的前五位还是后五位加密的。\nknown = b'TSCTF-J&#123;Ba'\nprint(sum(known[:5])%2) # 0\nprint(sum(known[5:10])%2) # 1\n&ensp;&ensp;&ensp;&ensp;由此可知第一组明文是与初始状态key的前五位进行异或运算的。而第二组明文是与经过一次变换的key的后五位进行异或运算的。由已知的明文与对应的密文进行异或运算得到对应的key：\nkey1 = long_to_bytes(bytes_to_long(cipher[:5])^bytes_to_long(known[:5]))\nprint(key1) #b'a2002'\n\nkey02 = long_to_bytes(bytes_to_long(cipher[5:10])^bytes_to_long(known[5:10]))\nprint(key02) #b'06\\x97~d'\n&ensp;&ensp;&ensp;&ensp;我们由此得知初始key的前五位是’a2002’。但第二次得到的key的后五位，即key02看起来是乱码，这是因为它是经过一轮’T0nihash’变换之后的key。’T0nihash’函数是已知的，我们可以以此进一步推算出初始密钥的后五位。\n&ensp;&ensp;&ensp;&ensp;’T0nihash’函数含有取余运算，直接逆推非常困难。但我们知道初始key只含有数字和小写字母，因此我们可以对初始key的后五位进行爆破。当初始key的前五位和初始key的后五位的’T0nihash’运算结果与key02相同时，我们就找到了正确的初始key。爆破脚本如下：\nkey1 = b'a2002'\ndef brute_5bytes():\n    table = b'abcdefghijkl0123456789'\n    for h in table:\n        for i in table:\n            for j in table:\n                for k in table:\n                    for l in table:\n                        tmp = (chr(h)+chr(i)+chr(j)+chr(k)+chr(l)).encode()\n                        if T0nihash(key1, tmp)[5:10]== b'06\\x97~d':\n                            print(tmp)\n                            return\n\nbrute_5bytes()\n# key = b'a20021130a'\n&ensp;&ensp;&ensp;&ensp;由此可知初始key是’a20021130a’\n&ensp;&ensp;&ensp;&ensp;我们得到了初始key，即可进行解密。解密的顺序和加密的顺序相同，均为从前往后，并且加解密时密钥的变换方式相同。由于我们不知道每一组的明文的sum值，因此要用try-except语句尝试两种情况。解密脚本如下：\nfrom Crypto.Util.number import long_to_bytes, bytes_to_long\n\ndef T0nihash(a,b):\n    if(bytes_to_long(b+a)!=0):\n        return long_to_bytes((bytes_to_long(a)*bytes_to_long(a+b))%bytes_to_long(b+a))\n    else:\n        return b'hahahahaha'\n\nkey = b'a20021130a'\ncipher = b\"5asdt\\x1d|\\xec&lt;\\x05\\x0e(\\x02\\xe7\\xae\\t\\xeeq+\\x0fq\\x0c\\xd0\\xe5e'\\xede\\xb38\\xca\\x90\\x1b'\\x04pWx\\xb1\\xc1nk\\xdbzmr\\xd4^\\x95l\\xa3L\\xb1\\x19\\xf5v\\xe1\\xfb\\xd5\\xa2/\\xca\\x00\\xd9\\r\\x1d\\xf2\\xffw\\xee\\x1a\\xf9z\\x9dT.\\xa1\\xee$&#125;\"\nknown = b'TSCTF-J&#123;Ba'\nout=''\n\nfor i in range(len(cipher)//5):\n    tmp=cipher[5*i:5*i+5]\n    try:\n        out+=str(long_to_bytes(bytes_to_long(tmp)^bytes_to_long(key[0:5])).decode('utf-8', 'strict'))\n        key=T0nihash(key[0:5],key[5:10])\n    except:\n        out+=str(long_to_bytes(bytes_to_long(tmp)^bytes_to_long(key[5:10])).decode())\n        key=T0nihash(key[5:10],key[0:5])\nprint(out)\n\n# TSCTF-J&#123;Bartleby_is_really_clever_and_his_math_is_much_better_than_T0ni_TATATAT&#125;\n&ensp;&ensp;&ensp;&ensp;flag终于求出来了…但hint是啥？懒得看了。\n&ensp;&ensp;\nL1nearAlgebra&ensp;&ensp;&ensp;&ensp;先看题目：\nfrom sage.all import *\nimport os\n\nflag = flag + os.urandom(62 - len(flag))\nM = Matrix(32,32)\nfor i in range(32):\n        M[i,i] = 2\nfor i in range(31):\n        M[i,i+1] = 1\nC = Matrix(32,32)\nidx = [i for i in range(1,32)]\nfor each , i in zip(flag[:31],idx):\n    C += each * M ^ i\nM = M.transpose()\nfor each, i in zip(flag[31:],idx):\n    C += each * M ^ i\nf = open('cipher.txt','w')\nf.write(str(list(C)))\nf.close()\n&ensp;&ensp;&ensp;&ensp;大概题目就是先造了一个矩阵M，然后把很多矩阵M用flag经过某种变换后叠在矩阵C上。但每叠一个矩阵M之后矩阵C的第一行和第一列的最后一个数就是上一个叠的矩阵M乘以的因数，也是flag的ASCII码。逐个把这个数取出来并减去相应的矩阵，就可以得到flag了。\n&ensp;&ensp;&ensp;&ensp;矩阵运算用的是sympy库。解题脚本：\nfrom sympy import Matrix, zeros\n\nC = Matrix(......) # 输入略\nM = zeros(32,32)\nfor i in range(32):\n        M[i,i] = 2\nfor i in range(31):\n        M[i,i+1] = 1\n\ncleartxt1 = []\ncleartxt2 = []\n\nfor i in range(1,32):\n    tmp1 = C[31,i-1]\n    tmp2 = C[0,32-i]\n    C -= M.T**(32-i)*tmp1\n    C -= M**(32-i)*tmp2\n    cleartxt1.append(chr(tmp1))\n    cleartxt2.append(chr(tmp2))\n\noutput = ''\nfor i in range(len(cleartxt1)*2):\n    output += (cleartxt1+cleartxt2)[len(cleartxt1)*2-1-i]\nprint(output)\n\n# TSCTF_J&#123;Jordan_Matrix_is_Important_in_L1near_Algebra&#125;Z1uÊ­l°uw\n&ensp;&ensp;&ensp;&ensp;flag提到了个叫Jordan矩阵的东西。之前没有了解过这个，等以后有时间的时候一定研究一下。\n&ensp;&ensp;\nMisc北邮人之声&ensp;&ensp;&ensp;&ensp;题目是一段倒放的音频。用Audacity的 效果-反相（时间） 选项处理音频，再适当降低速度，提升音高使语音更容易分辨。按国际航空无线电的字母读法听，即可听出flag。\n\nTSCTF-J{WELCOMETOBUPT}\n\n&ensp;&ensp;\nJust_Play&ensp;&ensp;&ensp;&ensp;一个奇怪的rpg。整个流程比较短。flag分为四个部分，每部分之间用下划线连接。首先翻一下游戏文件，找到FF.mp3，进行一段极其抽象的英语听力得到flag part4。在游戏中完成游戏流程，集齐宝石得到part3，击败最终boss bridge得到part1。在flag图迷宫的地形里可以看到由墙组成的part2。最后全部组合起来即是flag：\n\nTSCTF-J{Th1s_G4mE_1s_S0_Ez2zZzz_4_Y0U_ri9h7?}\n\n关于游戏：&ensp;&ensp;&ensp;&ensp;在游戏里找到茯苓，输入暗号”1919810”可以解锁非常强的角色，前期打小boss和刷钱很快。但最终打bridge时这个角色会被ban掉。\n&ensp;&ensp;&ensp;&ensp;塔上有坑。上塔之前最好备份一下存档。\n&ensp;&ensp;&ensp;&ensp;游戏中的字体的0和O很难区分，从游戏中读flag时也要注意一下。\n&ensp;&ensp;\nstrange base64&ensp;&ensp;&ensp;&ensp;只要写一个交互脚本把777个base64接收后解码成字节再发送出去就可以。默认编码即可，不用特意考虑中文编码问题。\n&ensp;&ensp;&ensp;&ensp;解题脚本：\nimport base64\nfrom pwn import *\n\nio = remote('xxx.xxx.xxx.xxx', xxxxx) # 题目环境ip地址+端口号\nfor i in range(777):\n    io.recvuntil(b'\\'')\n    input = io.recvuntil(b'\\'')\n    io.recvline()\n    input = input[:-1]\n    print(input)\n    v1 = base64.b64decode(input)\n    v3 = v1.decode()\n    print(v3)\n    io.sendline(v3)\n    print(io.recvline())\nio.interactive()\n\n# TSCTF-J&#123;easytointeractive&#125;\n&ensp;&ensp;\n赛后问卷&ensp;&ensp;&ensp;&ensp;略\n&ensp;&ensp;\nWeb词超人&ensp;&ensp;&ensp;&ensp;题目是一个单词测试的网站，题很多，似乎全部做对才能得到flag。但每道题的答案都直接在网页源代码里给了出来。用BurpSuite抓包发现判题的机制是网页将每道题的id和用户填写的答案POST给服务器，再由服务器返回结果。因此，可以用Word的搜索/替换功能，将网页源代码保留题目ID和答案，替换成网页POST给服务器的格式，发送给服务器就可以返回flag: \n\nTSCTF-J{naughty_or_diligent-which_type_you_are?^_^}\n\n&ensp;&ensp;\n真真历险记&ensp;&ensp;&ensp;&ensp;进网页后按F12，在源代码的style.css里可以找到三段奇怪的注释，只由[(])+!几个字符组成，很明显是JSf*ck，将三段编码连起来，用解码即可得到flag\n&ensp;&ensp;&ensp;&ensp;http://www.hiencode.com/jsfuck.html\n&ensp;&ensp;&ensp;&ensp;需要注意的是，由于Jsf*ck的特性，分别解码是不能得到完整的flag的，必须将三段代码按顺序连起来一起解码才能得到flag：\n\nTSCTF-J{1_tEs7_y0Ur_c()de}\n\n&ensp;&ensp;\nPwncheckin&ensp;&ensp;&ensp;&ensp;是非常简单的栈溢出，直接nc题目地址，只要溢出就能得到flag。flag具体是啥忘了。\n&ensp;&ensp;\n&ensp;&ensp;\nEnd总之，感谢学长们用心准备的这次比赛。之后有时间的时候会把今年MoeCTF的WP给整理一下发出来。因为它虽然是西电的新生赛，但其中很多题和想法对我自己来说还是很有价值的，同时很多做题时学到的知识和思路也快忘记了，整理一遍wp也权当复习，作为笔记放在这里给自己参考和提示。（意识到写wp的重要性）\n","categories":["Writeup"],"tags":["CTF","Writeup"]},{"title":"(水)关于linux系统网卡驱动的安装","url":"/posts/2/index.html","content":"作为一个刚刚接触linux系统的小白，目前还在熟悉linux下一些基本操作的方法。（Debian系统）\n刚好有个闲置的usb无线网卡，是Tenda的某个型号。想把它安装在linux上来连接学校的无线网。\n连接在电脑上之后发现识别不了网卡。于是花了点时间解决这件事情。虽然没什么技术含量，但很多东西也是我第一次接触，因此在这里记录一下步骤和踩过的坑。\n0x01 RTL8192FU连接网卡？&ensp;&ensp;&ensp;&ensp;先用lsusb查看一下usb网卡有没有正确连接到linux上。\n\n&ensp;&ensp;&ensp;&ensp;正常来说网卡在lsusb上会显示为 WLAN Adapter，在这里却显示为DISK。突然想起这个网卡是“免驱型”，插在windows系统上不会立刻显示为网卡，而是显示为一个CD-ROM来提供windows下的驱动安装程序，将CD驱动器右键弹出才能作为网卡使用。\n\n&ensp;&ensp;&ensp;&ensp;查阅网络了解到，linux命令行中实现该操作的命令是”eject”。先在debian软件包仓库手动下载一个eject的.deb包，再离线拷贝到linux系统上安装，将 /dev/sr0 分区弹出，然后就可以在lsusb看到网卡了。（如果安装的是Desktop版linux，直接右键光盘点弹出即可）\n\n寻找网卡驱动&ensp;&ensp;&ensp;&ensp;因为之前在windows下用过这个usb网卡，所以知道芯片是RTL8192FU。因此直接按照网卡芯片的型号在github上搜索驱动的源代码。https://github.com/BrightX/rtl8192fu\n&ensp;&ensp;&ensp;&ensp;下载解压出来拷贝到U盘，插到linux上。\n编译并安装驱动&ensp;&ensp;&ensp;&ensp;网卡驱动应该和一般的程序安装步骤差不多，首先要从官网下载对应版本的linux-header内核头文件并拷贝到linux安装，然后在程序的源代码根目录下建立Makefile，用make和make install编译安装。\n&ensp;&ensp;&ensp;&ensp;在根目录下已经发现了Makefile，直接 make &amp; make install即可安装驱动。\n\n有些linux系统发行版（比如Ubuntu LTS 22.04），刚装好系统时甚至连安装网卡驱动需要的编译环境（gcc编译器、make）都没有。而在没有网卡驱动，无法联网的情况下也不可能用apt包管理器来安装这些工具。对于一些比较简单的程序，可以直接去系统的官方软件包仓库https://www.debian.org/distrib/packages在线下载.deb包，再拷贝到linux上用dpkg离线安装。但对于gcc、make这样的程序，依赖的库比较多。对应着依赖关系表，挨个手动下载.deb包是一件非常折磨的事情。\n这种情况下有一个比较自动的解决方案，就是在自己的电脑上配置一个和该linux系统相同的虚拟机，将该虚拟机连接网络，在该虚拟机上安装apt-rdepends\nOctane@vmware:~$ sudo apt install apt-rdepends\n这个工具可以帮助我们获取一个软件包的依赖。我们可以利用这个工具配合apt下载软件包依赖的所有包和库。\nOctane@vmware:~$ apt-get download $(apt-rdepends gcc make|grep -v \"^ \")\n然后将下载的.deb软件包拷贝到linux系统上，用dpkg安装即可。\n但要注意，这个方法一定要在和需要安装依赖的linux系统版本完全相同的虚拟机上使用。如果用的系统有区别，即使使用的包管理器是相同的（如Ubuntu和Kali），但由于不同linux版本使用的软件包仓库不同，安装后本地依赖关系会变得一团糟。虽然此时有了gcc和make，可以编译和安装网卡驱动，也可以正常联网，但连上网后apt无法安装或卸载任何软件包，aptitude都没法安装了，也无法自动修复依赖关系。我当时到这里没有办法让系统恢复正常，只能重装了orz。\n\n\n&ensp;&ensp;&ensp;&ensp;但安装过程中出现了一个报错。大概的意思是Makefile的修改时间要比系统时间要晚，因此编译很可能失败。这是因为刚烧录好的系统，系统时间是比较之前的，而且在没有联网的情况下也无法同步时间到最新。为解决这个问题，将系统时间手动调整，调到Makefile的修改时间之后即可。用make clean清理一下，再用make重新编译。\n&ensp;&ensp;&ensp;&ensp;然后make install，顺利地安装上了网卡驱动。\n&ensp;&ensp;&ensp;&ensp;此时用nmcli dev wifi搜索网络，可以正常连接portal校园网，至此网卡安装完毕。\n&ensp;&ensp;&ensp;&ensp;至于校园网的连接，我使用的这个linux没有安装x-server，也就是说不能用有图形界面的浏览器。但对于linux的命令行，有一个傻瓜式文本浏览器w3m可供使用。用这个浏览器可以轻松在页面填写账号登录校园网。\n0x02 RTL8192EU&ensp;&ensp;&ensp;&ensp;又是另外一个USB无线网卡，芯片是8192EU。似乎要比8192FU友好一些，插入电脑就能自动用lsusb识别到型号，ifconfig也可以识别到网卡。但信号似乎很差，而且网络完全连不上…\n\n&ensp;&ensp;&ensp;&ensp;看来还是要装驱动。于是又从Github搜索到了相应的驱动。\n&ensp;&ensp;&ensp;&ensp;老办法，解压，拷贝，Make &amp; Make install 安装…一切看起来都很顺利，再连接一下网络，为什么还是和之前一样无法连接??难道网卡是坏掉的…?\n&ensp;&ensp;&ensp;&ensp;上网查阅了一下资料，linux内核模块本身就带有支持RTL系无线网卡的驱动（rtl8xxxu），而RTL8192EU是兼容这个驱动的，因此能被linux自动识别的。信号不好和无法连接是由于这个驱动对这个网卡的支持比较差。用 make &amp; make install 安装该驱动后，设备使用的还是内核的驱动。因此想要让我们安装的驱动发挥作用，就需要把内核模块中默认的rtl8xxxu驱动换掉。\noctane@octanePC:/mnt/sda/rtl8192eu-linux-5.11.2$ sudo rmmod rtl8xxxu\noctane@octanePC:/mnt/sda/rtl8192eu-linux-5.11.2$ sudo echo \"blacklist rtl8xxxu\" >> /etc/modprobe.d/blcaklist-rtl8xxxu.conf\noctane@octanePC:/mnt/sda/rtl8192eu-linux-5.11.2$ cp -ar . /usr/src/rtl8192eu-1.0\noctane@octanePC:/mnt/sda/rtl8192eu-linux-5.11.2$ sudo dkms add -m rtl8192eu -v 1.0\noctane@octanePC:/mnt/sda/rtl8192eu-linux-5.11.2$ sudo dkms install -m rtl8192eu -v 1.0\n&ensp;&ensp;&ensp;&ensp;然后就可以正常使用了。性能感觉比8192FU还好一些。\n&ensp;&ensp;&ensp;&ensp;而之前的RTL8192FU，由于它本身就不兼容内核中的rtl8xxxu驱动。因此用 make &amp; make install 直接安装驱动，不将驱动整合进linux内核也可以使用。\n0x03 总结？&ensp;&ensp;&ensp;&ensp;总之，最好的办法就是使用与linux内核兼容的网卡。大多数笔记本内置的intel无线网卡一般都是内核自带驱动的，实测AC3165、AC9560、AX200、AX211都可以直接兼容linux5.，不用安装驱动就能很好地工作。需要usb无线网卡时优先选择标明网卡芯片的型号的。其次再选非免驱版，自己查看网卡芯片型号并安装驱动。免驱版因为有一个驱动安装的分区，每次使用前要先弹出一下，对linux的使用不是很友好。\n","categories":["notes"],"tags":["notes"]},{"title":"Hello_World","url":"/posts/1/index.html","content":"终于把博客搭好了…目前页面还比较简陋，但至少能上了（大概\n以后主要会在博客更新参加过的CTF的Writeup、做题和学习记录。也会贴一些可能没什么技术含量的笔记，比如一些配置环境时遇到的问题。\n","categories":[],"tags":[]}]