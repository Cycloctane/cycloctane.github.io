[{"title":"Octane的moeCTF_2022 Writeup","url":"/posts/36640/index.html","content":"OctaneのCTF初体验！\n准备在这里补（shui）一篇WP。因为题目数量挺多的，有些题目也是新手引导向的，或者仅仅涉及一些工具的基本使用方法，所以不会把所有的题目全都写一遍题解，还是主要写Crypto板块的一些题解。感觉有些题还是有记录一下的价值的，在复习的同时也可以把那些做题时没太深究的题深入研究一下。\nCrypto一次就好&ensp;&ensp;&ensp;&ensp;先看题目：\nfrom Crypto.Util.strxor import strxor\nfrom Crypto.Util.number import *\nfrom gmpy2 import powmod,next_prime\nfrom FLAG import flag\nimport codecs\n\nc = b'Just once,I will accompany you to see the world'\nflag = flag.ljust(len(c),'#')\nkey = strxor(flag.encode(), c)\nm = bytes_to_long(key)\n\np = getPrime(512)\nq = next_prime(p)\nN = p*q\ne = 0x10001\n\ngift = powmod(m, e, N)\n\nprint(gift)\nprint(N)\n\n# 输出略\n&ensp;&ensp;&ensp;&ensp;大概就是用一次性密码本加密flag，将key再用rsa加密。rsa加密时用的是相邻素数，因此用yafu很快就能分解N得到p和q然后解密出一次性密码本的key。再用该key和c进行异或就能得到flag。当时就是通过这道题了解到了yafu这个工具。\n&ensp;&ensp;&ensp;&ensp;解题脚本：\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\nfrom Crypto.Util.strxor import strxor\n\n#使用yafu.exe分解n得到pq\np = 12821668064849826676074701213910298504451620184307130249376361333490782040849300923713647818247010549622664747770828229853003308659470956068108542842690571\nq = 12821668064849826676074701213910298504451620184307130249376361333490782040849300923713647818247010549622664747770828229853003308659470956068108542842690393\ngift = 127749242340004016446001520961422059381052911692861305057396462507126566256652316418648339729479729456613704261614569202080544183416817827900318057127539938899577580150210279291202882125162360563285794285643498788533366420857232908632854569967831654923280152015070999912426044356353393293132914925252494215314\ne = 65537\nc = b'Just once,I will accompany you to see the world'\n\nd = gmpy2.invert(e, (p - 1) * (q - 1))\nm = pow(gift, d, p * q)\nflag = strxor(long_to_bytes(m), c)\nprint(flag)\n\n# moectf&#123;W0w_y02_k5ow_w6at_1s_one_t1m3_pa7&#125;######\n&ensp;&ensp;\n0rsa0&ensp;&ensp;&ensp;&ensp;题目：\nfrom Crypto.Util.number import *\nfrom flag import flag\n\nassert flag[0:7] == b'moectf&#123;'\nassert flag[-1:] == b'&#125;'\nflag = flag[7:-1]\nassert len(flag) == 32\n\nm1 = bytes_to_long(flag[0:16])\nm2 = bytes_to_long(flag[16:32])\n\ndef enc1(m):\n    p = getPrime(512)\n    q = getPrime(512)\n    n = p * q\n    e = 3\n    c = pow(m,e,n)\n    return n,e,c\n\ndef enc2(m):\n    p = getPrime(512)\n    q = getPrime(512)\n    e = 65537\n    d = inverse(e,(p-1)*(q-1))\n    n = p * q \n    dp2 = d % (p-1)\n    c = pow(m,e,n)\n    return n,e,c,dp2\n\nn1,e1,c1 = enc1(m1)\nn2,e2,c2,dp2 = enc2(m2)\n\nprint(\"n1=\"+ str(n1))\nprint(\"e1=\"+ str(e1))\nprint(\"c1=\"+ str(c1))\nprint(\"n2=\"+ str(n2))\nprint(\"e2=\"+ str(e2))\nprint(\"c2=\"+ str(c2))\nprint(\"dp2=\"+ str(dp2))\n\n# 输出略\n&ensp;&ensp;&ensp;&ensp;两个常见的rsa攻击套路。\n&ensp;&ensp;&ensp;&ensp;flag被分为两段分别加密。enc1是低指数小明文攻击。由于$e$比较小（只有3），明文的$e$次方仍然小于$n$，加密得到的$c=m^{e}$。因此将c直接开e次方即可得到flag。解题脚本如下：\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\nc1 = 1402983421957507617092580232325850324755110618998641078304840725502785669308938910491971922889485661674385555242824\ne1 = 3\n\nm = gmpy2.iroot(c1, 3)[0]\ncleartxt = long_to_bytes(m)\nprint(cleartxt)\n\n# T8uus_23jkjw_asr\n&ensp;&ensp;&ensp;&ensp;enc2是dp泄露攻击。\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\nn2 = 159054389158529397912052248500898471690131016887756654738868415880711791524038820158051782236121110394481656324333254185994103242391825337525378467922406901521793714621471618374673206963439266173586955520902823718942484039624752828390110673871132116507696336326760564857012559508160068814801483975094383392729\ne2 = 65537\nc2 = 37819867277367678387219893740454448327093874982803387661058084123080177731002392119369718466140559855145584144511271801362374042596420131167791821955469392938900319510220897100118141494412797730438963434604351102878410868789119825127662728307578251855605147607595591813395984880381435422467527232180612935306\ndp2 = 947639117873589776036311153850942192190143164329999603361788468962756751774397111913170053010412835033030478855001898886178148944512883446156861610917865\n\nfor i in range(1, e2):\n    p = (dp2 * e2 - 1) // i + 1\n    if n2 % p == 0:\n        q = n2 // p\n        print(p)\n        print(q)\n        break\n\nd = gmpy2.invert(e2, (p - 1) * (q - 1))\nm = pow(c2, d, p * q)\nprint(long_to_bytes(m))\n\n# _3d32awd!5f&amp;#@sd\n&ensp;&ensp;&ensp;&ensp;因此得到flag：\n\nmoectf{T8uus_23jkjw_asr_3d32awd!5f&amp;#@sd}\n\n&ensp;&ensp;\nWeird_E_Revenge&ensp;&ensp;&ensp;&ensp;先看题目：\nfrom Crypto.Util.number import *\nimport random\nfrom secret import flag\ntable='abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\npad=100-len(flag)\nfor i in range(pad):\n    flag+=random.choice(table).encode()\ne=343284449\nm=bytes_to_long(flag)\nassert m>(1&lt;&lt;512)\nassert m&lt;(1&lt;&lt;1024) \np=getPrime(512)\nq=getPrime(512)\nr=getPrime(512)\nprint('p=',p)\nprint('q=',q)\nprint('r=',r)\nn1=p*q\nn2=q*r\nc1=pow(m,e,n1)\nc2=pow(m,e,n2)\nprint('c1=',c1)\nprint('c2=',c2)\n\n# 输出略\n&ensp;&ensp;&ensp;&ensp;flag经过填充后分别用n1、n2加密，而n1、n2的因数p、q、r都是已知的，似乎解密需要的参数都是已知的。先尝试用RSA基本解密方法解。\nfrom gmpy2 import invert\nfrom Crypto.Util.number import long_to_bytes\nfrom libnum import solve_crt\n\ne = 343284449\np = 11820891196647569262137841192985418014377132106496147254821784946481523526822939129065042819464351666077658751406165276121125571355594004514547517855730743\nq = 10450390015864176713581330969519712299844487112687677452105216477861582967322473997670559995588440097951786576039009337782247912476227937589298529580432797\nr = 9484954066160968219229920429258150817546418633451929876581842443665029377287119340232501682142185708534413073877473741393278935479791561681402673403009771\nc1 = 69574855207460025252857869494766338442370688922127811393280455950372371842144946699073877876005649281006116543528211809466226185922844601714337317797534664683681334132261584497953105754257846471069875622054326463757746293958069752489458646460121725019594141157667480846709081917530190233900184428943585065316\nc2 = 66183492015178047844987766781469734325646160179923242098082430373061510938987908656007752256556018402101435698352339429316390909525615464024332856855411414576031970267795270882896721069952171988506477519737923165566896609181813523905810373359029413963666924039857159685161563252396502381297700252749204993228\n\nd = invert(e, (p-1)*(q-1))\nm1 = pow(c1, d, p*q)\nprint(long_to_bytes(m1))\n\n# Traceback (most recent call last):\n#   File \"solve_weirdrevenge.py\", line 12, in &lt;module>\n#     d = invert(e, (p-1)*(q-1))\n# ZeroDivisionError: invert() no inverse exists\n&ensp;&ensp;&ensp;&ensp;在解密过程中无法找到$e$关于$(p-1)(q-1)$或者关于$(q-1)(r-1)$的逆元。不能用基本方式解密。这是因为$e$与$(q-1)$不互素，从而与$(p-1)(q-1)$和$(q-1)(r-1)$都不互素，因此解不出逆元。但观察题目可以发现相同的明文由不同的n1、n2分别加密了两次。用同余式可以表示成这样：$$m^{e}\\ \\equiv\\ c_{1}\\ mod\\ n_{1}$$$$m^{e}\\ \\equiv\\ c_{2}\\ mod\\ n_{2}$$\n&ensp;&ensp;&ensp;&ensp;又$n_{1}=p\\cdot q$，$n_{2}=q\\cdot r$。由同余式的性质可以得到如下的同余方程式组：$$m^{e}\\ \\equiv\\ c_{1}\\ mod\\ p$$$$m^{e}\\ \\equiv\\ c_{2}\\ mod\\ r$$\n&ensp;&ensp;&ensp;&ensp;对于这样的同余方程式组，可以用中国剩余定理（CRT）求出一个与$m^{e}$等价的特解$x$。然后可以用$e$关于$(p-1)(r-1)$的逆元解密$x$得到明文，从而避开与$e$不互素的$(q-1)$。\n&ensp;&ensp;&ensp;&ensp;python的第三方库libnum有函数solve_crt可以直接调用。解题脚本如下：\nfrom gmpy2 import invert\nfrom Crypto.Util.number import long_to_bytes\nfrom libnum import solve_crt\n\ne = 343284449\np = 11820891196647569262137841192985418014377132106496147254821784946481523526822939129065042819464351666077658751406165276121125571355594004514547517855730743\nq = 10450390015864176713581330969519712299844487112687677452105216477861582967322473997670559995588440097951786576039009337782247912476227937589298529580432797\nr = 9484954066160968219229920429258150817546418633451929876581842443665029377287119340232501682142185708534413073877473741393278935479791561681402673403009771\nc1 = 69574855207460025252857869494766338442370688922127811393280455950372371842144946699073877876005649281006116543528211809466226185922844601714337317797534664683681334132261584497953105754257846471069875622054326463757746293958069752489458646460121725019594141157667480846709081917530190233900184428943585065316\nc2 = 66183492015178047844987766781469734325646160179923242098082430373061510938987908656007752256556018402101435698352339429316390909525615464024332856855411414576031970267795270882896721069952171988506477519737923165566896609181813523905810373359029413963666924039857159685161563252396502381297700252749204993228\n\nlist1 = [c1, c2]\nlist2 = [p, r]\nx = solve_crt(list1, list2)\nd = invert(e, (p - 1) * (r - 1))\nm = pow(x, d, p * r)\nprint(long_to_bytes(m))\n\n# moectf&#123;Th1s_iS_Chinese_rEm41nDeR_The0rEm_CRT!&#125;YWMZSTyfRvhjTCJuQCwALQBcWHFCgTDIZWJaxRUzBPCmFOnbDTRBau\n&ensp;&ensp;\nSignin&ensp;&ensp;&ensp;&ensp;题目：\nfrom Crypto.Util.number import *\nfrom secret import flag\nm=bytes_to_long(flag)\np=getPrime(512)\nq=getPrime(512)\nprint('p=',p)\nprint('q=',q)\nn=p*q\ne=65537\nc=pow(m,e,n)\nprint('c=',c)\n\n# 输出略\n&ensp;&ensp;&ensp;&ensp;虽然是签到题，但却在很长一段时间内一直都没做出来。后来才从在HNCTF上遇到的cot1007师傅学到了此类情况的做法。\n&ensp;&ensp;&ensp;&ensp;题目看起来很友好，加密用到的所有的数都直接给出来了。但$e$与$q-1$不互素，是无法用常规做法解出flag的。也不能像Weird_E_Revenge一样用中国剩余定理求解。\n&ensp;&ensp;&ensp;&ensp;实际上解法很简单。虽然$e$与$q-1$不互素，但其实$m&lt;p$。因此可以直接将$c\\ mod\\ p$，将问题变为$m^{e}\\ \\equiv\\ c’\\ mod\\ p$，绕过有问题的$q$。解题脚本：\nfrom Crypto.Util.number import long_to_bytes\nfrom gmpy2 import invert\n\ne = 65537\np= 12408795636519868275579286477747181009018504169827579387457997229774738126230652970860811085539129972962189443268046963335610845404214331426857155412988073\nq= 12190036856294802286447270376342375357864587534233715766210874702670724440751066267168907565322961270655972226761426182258587581206888580394726683112820379\nc= 68960610962019321576894097705679955071402844421318149418040507036722717269530195000135979777852568744281930839319120003106023209276898286482202725287026853925179071583797231099755287410760748104635674307266042492611618076506037004587354018148812584502385622631122387857218023049204722123597067641896169655595\n\nc1 = c%p\nphi = p-1\nd = invert(e, phi)\nm = pow(c1, d, p)\n\nprint(long_to_bytes(m))\n\n# moectf&#123;Oh~Now_Y0u_Kn0W_HoW_RsA_W0rkS!&#125;\n&ensp;&ensp;\n\n&ensp;&ensp;&ensp;&ensp;下面几道题先把自己的解题脚本贴在这，解题思路以后一定补完（\n\nSmooth&ensp;&ensp;&ensp;&ensp;解题脚本：\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\nc = int(\n    '0x3cc51d09c48948e2485820f6758fb10c7693c236acc527ad563ba8369c50a0bc3f650f39a871ee7ef127950ed916c5f4dc69894e11caf9d178cd7e8f9bf9af77e1c69384cc5444da64022b45636eeb5b7a221792880dd242be2bb99be3ed02c430c2b77d4912bec1619d664e066680910317c2bb0c87fafdf25f0a2400103278f557b8eca51d3b67d61098f1ab68da072bb2810596180afbc81a840cd24efef4d4113235160e725a5af4824dc716d758b3bc792f2458e979398e001b27e44d21682e2ef80ae94e21cd09a12e522ca2e569df72f012fa40341645445c6e68c6233a8a39e5b91eb14b1ccfa61c9bad25e8e3285a22da27cd506ddd63f207517a4e8ede00b104d8806ff4c0e3162c3de69169d7e584952655272b96d39d242bb83019c7eab1ceb0b4b287591e1e0a5b6378e70340a82d3430c5925d215f31fda6d9d0bccea240591b22a3d0f6b5bf4ddf1243d71aca0fd53045c352c8c5497ebcdbd7ac11083d63aba7c053604fda2430c317a4e04702b5ad539e110f101165b21dcd9fdb5ba7324acdba6a506244ce7c911197dfe067441fe7488d164c050f45ef6476aaf399cedde1793cceb8c21d88ec8ecf5e17df27586713d7dd9566ec5023cfef75422b73e2d5a932c661b3cfdf9c4bda12b64380d2be1aa957c3e1416e068937bafe79b8cf303296792388e9c197702e11e7ded6088ae992d352b23a4a27',\n    16)\nN = int(\n    '0xdc77f076092cbe81c44789ccfc1b2ca55eabae65f44cf34382799e8bbb42d4d6c032bd897c21df1da401929d82deb56264823a757f6cacf63e0037146026cbab32ab9e4abc783dcabaac2b7ccc439937be3ab0fbf149524ff29ef0fe6f27e45215d74b40597c70e8207159dc7f542c2a6828500016480053dfc2d8dbf8fcdf6700640184c8f3318f7aab2e17e116edf680592f5eae951159bb8c20cfbd0cbab8b4b95925b5068038d0377a55a4d346ebbf53a1c2943b7c17e1b9d4a1b77916da2e15140b05b96655906942a07d04b7e25fa7521b3b7ae26eda68375a8b8ef2d5b4704a28168b236de97f24a663f0d0a3aeab47767dfe75a21662f5f25ef7f7d4b25c90fd7bcdd7137c23f03b6ea4209f8fb9b4628355e6ad62e6467d26666d3d1b0e6f078c5f3866413a6fcd3c1dc2ff3a5ab286e339d5c72f4d2f0473a4faddcba6b031bb6ec226fd4b319834b5029f09ea0ffeb5b6ed182d5a13675571b6708c38299118043390343e2f79edebd2ae0e0a765a3aebf776f54ca983cdae8547547cfc8430f7222aefa77301d7cc7c03b1451b6603028b21fea869d35138a9c83919985a91b3fdfa934f25a442cc10349b0ed6f2ee3955d40249e8b3fb9f1955534ee06cee41a3ad2d6ff7dbdb0f01e47b9e4d04f65232f5579135ae035e8ba2d1fe6465a730dcc8b9ba3a558ab38f040ea510757d25e92f886c50c24ad967f1',\n    16)\n\ndef Pollards_p_1(N): # Pollards 光滑数算法\n    a = 2\n    n = 1\n    while True:\n        a = pow(a, n, N)\n        res = gmpy2.gcd(a - 1, N)\n        if res != 1 and res != N:\n            return res\n        n += 1\n\ne = 65537\np = Pollards_p_1(N)\nq = N // p\nd = gmpy2.invert(e, (p - 1) * (q - 1))\nm = pow(c, d, N)\n\nfor i in range(2, 1730): # 根据同余式的性质和Wilson定理推导\n    m *= (p - i)\ncleartxt = m % p\n\nprint(long_to_bytes(cleartxt))\n\n# moectf&#123;Charming_primes!_But_Sm0oth_p-1_1s_vu1nerab1e!&#125;\n&ensp;&ensp;\nezcbc&ensp;&ensp;&ensp;&ensp;解题脚本：\nfrom Crypto.Util.number import *\n\nc0 = 748044282\nc = [748044282, 2053864743, 734492413, 675117672, 1691099828, 1729574447, 1691102180, 657669994, 1741780405, 842228028, 1909206003, 1797919307]\n\nIV = bytes_to_long(b'cbc!')\ncleartxt0 = b'moec'\ncleartxt = []\n\ncleartxt.append(cleartxt0.decode('utf8', 'ignore'))\nk = IV ^ bytes_to_long(cleartxt0) ^ c0\n\nfor i in range(len(c) - 1):\n    txt = long_to_bytes((k ^ c[i + 1] ^ c[i]))\n    cleartxt.append(txt.decode('utf8', 'ignore'))\nprint(cleartxt)\n\n# moectf&#123;es72b!a5-njad!@-#!@$sad-6bysgwy-1adsw8&#125;\n&ensp;&ensp;\nezhash&ensp;&ensp;\nbabyNETpart1&ensp;&ensp;&ensp;&ensp;解题脚本：\nfrom Crypto.Util.number import long_to_bytes\nfrom Crypto.Util.number import bytes_to_long\nfrom Crypto.Cipher import AES\n\ndef encrypt(plaintext, key):\n    assert len(plaintext) == 32\n    assert len(key) == 16\n\n    left = plaintext[:16]\n    right = plaintext[16:]\n\n    for i in range(3):\n        aes = AES.new(key, AES.MODE_ECB)\n        new_right = long_to_bytes(\n            bytes_to_long(aes.encrypt(right)) ^ bytes_to_long(left))\n        new_left = right\n        left = new_left\n        right = new_right\n    return left + right\n\n\ndef decrypt(ciphertext, key):\n    assert len(ciphertext) == 32\n    assert len(key) == 16\n\n    left = ciphertext[:16]\n    right = ciphertext[16:]\n\n    for i in range(3):\n        aes = AES.new(key, AES.MODE_ECB)\n        last_right = left\n        last_left = long_to_bytes(\n            bytes_to_long(right) ^ bytes_to_long(aes.encrypt(left)))\n        left = last_left\n        right = last_right\n    return left + right\n\n\nkey1 = b'this_is_the_key~'\nkey2 = b'to_enlength_key!'\ncipher = long_to_bytes(\n    int(0x8b6d863f3e89fd2698ff90e8409502ebf485e17449cdaceb6f5cb2e781524ce4))\n\ndecipher = decrypt(cipher, key1)\ndecipher = encrypt(decipher, key2)\ndecipher = decrypt(decipher, key1)\nprint(decipher)\n\n# b'it_is_just_the_fy0u_can_d0_what?'\npart2&ensp;&ensp;&ensp;&ensp;解题脚本：\nfrom Crypto.Util.number import long_to_bytes\nfrom Crypto.Cipher import AES\n\nclass AES_CBC(object):\n\n    def __init__(self, key, iv):\n        self.key = key\n        self.mode = AES.MODE_CBC\n        self.iv = iv\n\n    def pad_byte(self, b):\n        bytes_num_to_pad = AES.block_size - (len(b) % AES.block_size)\n        return b + bytes([bytes_num_to_pad]) * bytes_num_to_pad\n\n    def encrypt(self, text):\n        cryptor = AES.new(self.key, self.mode, self.iv)\n        text = self.pad_byte(text)\n        self.ciphertext = cryptor.encrypt(text)\n        return self.ciphertext\n\n    def decrypt(self, text):\n        unpad = lambda s: s[:-ord(s[len(s) - 1:])]\n        cryptor = AES.new(self.key, self.mode, self.iv)\n        aesStr = cryptor.decrypt(text)\n        aesStr = str(unpad(aesStr), encoding='utf8')\n        return aesStr\n\nencdata = long_to_bytes(int(0x1fe9c9b13b8af4f59857d9bc5df1bfbc9df34b8a4a33455b244fb0d857f98c3ea8a62b0190e7336dde76365e65e955c4))\nK = b'it_is_just_the_f'\nIV = b'y0u_can_d0_what?'\npc = AES_CBC(K, IV)\ndata = pc.decrypt(encdata)\nprint(data)\n\n# Congratulations!_You_have_get_the_flag!\n&ensp;&ensp;\nMiniMiniBackpack&ensp;&ensp;&ensp;&ensp;解题脚本：\nfrom Crypto.Util.number import long_to_bytes\n\nkey = [......] # 输入略\nc = ......\n\nL = len(key)\ncleartxt = []\nv1 = c\n\nfor i in range(L):\n    if v1 - key[-1 - i] &lt; 0:\n        v1 -= 1\n        cleartxt.append(0)\n    if v1 - key[-1 - i] >= 0:\n        v1 -= key[-1 - i]\n        cleartxt.append(1)\n        \nprint(long_to_bytes(int(''.join(map(str, cleartxt)),2)))\n\n# moectf&#123;Co#gRa7u1at1o^s_yOu_c6n_d3c0de_1t&#125;\n&ensp;&ensp;\n不止一次&ensp;&ensp;\nMiscHamming&ensp;&ensp;&ensp;&ensp;解题脚本：\nnoisemsg = [......] # 输入略\nflag = '0'\n\nfor i in range(len(noisemsg)):\n    tmp = noisemsg[i]\n\n    check1mem = 0\n    check1 = [\n        tmp[1], tmp[3], tmp[5], tmp[7], tmp[9], tmp[11], tmp[13],\n        tmp[15]\n    ]\n    if check1.count(1) % 2 == 0:\n        pass\n    else:\n        check1mem = 1\n\n    check2mem = 0\n    check2 = [\n        tmp[2], tmp[3], tmp[6], tmp[7], tmp[10], tmp[11], tmp[14],\n        tmp[15]\n    ]\n    if check2.count(1) % 2 == 0:\n        pass\n    else:\n        check2mem = 1\n\n    check3mem = 0\n    check3 = [\n        tmp[4], tmp[5], tmp[6], tmp[7], tmp[12], tmp[13], tmp[14],\n        tmp[15]\n    ]\n    if check3.count(1) % 2 == 0:\n        pass\n    else:\n        check3mem = 1\n\n    check4mem = 0\n    check4 = [\n        tmp[8], tmp[9], tmp[10], tmp[11], tmp[12], tmp[13], tmp[14],\n        tmp[15]\n    ]\n    if check4.count(1) % 2 == 0:\n        pass\n    else:\n        check4mem = 1\n\n    check0mem = [check1mem, check2mem, check3mem, check4mem]\n\n    if check4mem == 1:\n        if check3mem == 1:\n            if check2mem == 1:\n                if check1mem == 1:\n                    errorplace = 15\n                else:\n                    errorplace = 14\n            else:  #c2==0\n                if check1mem == 1:\n                    errorplace = 13\n                else:\n                    errorplace = 12\n        else:  #c3==0\n            if check2mem == 1:\n                if check1mem == 1:\n                    errorplace = 11\n                else:\n                    errorplace = 10\n            else:  #c3==0\n                if check1mem == 1:\n                    errorplace = 9\n                else:\n                    errorplace = 8\n    else:  #c4==0\n        if check3mem == 1:\n            if check2mem == 1:\n                if check1mem == 1:\n                    errorplace = 7\n                else:\n                    errorplace = 6\n            else:  #c2==0\n                if check1mem == 1:\n                    errorplace = 5\n                else:\n                    errorplace = 4\n        else:  #c3==0\n            if check2mem == 1:\n                if check1mem == 1:\n                    errorplace = 3\n                else:\n                    errorplace = 2\n            else:  #c2=0\n                if check1mem == 1:\n                    errorplace = 1\n                else:\n                    errorplace = 0\n\n    if tmp[errorplace] == 1:\n        tmp[errorplace] = 0\n    elif tmp[errorplace] == 0:\n        tmp[errorplace] = 1\n\n    cleartxt = [\n        tmp[3], tmp[5], tmp[6], tmp[7], tmp[9], tmp[10], tmp[11],\n        tmp[12], tmp[13], tmp[14], tmp[15]\n    ]\n\n    for k in range(len(cleartxt)):\n        cleartxt[k] = str(cleartxt[k])\n\n    flag+=''.join(cleartxt)\n\ncleartxt = ''\nfor i in range(len(flag)//8):\n    cleartxt += chr(int(flag[8*i:8*i+8], 2))\nprint(cleartxt)\n\n# Once upon a time, there were 1023 identical bottles, 1022 of which were plain water and one of which was poison. Any creature that drinks the poison will die within a week. Now, with 10 mice and a week, how do you tell which bottle has poison in it?\n# moectf&#123;Oh_Bin4ry_Mag1c_1s_s0o_c0O1!&#125; Great!\n&ensp;&ensp;\n","categories":["Writeup"],"tags":["CTF","Writeup"]},{"title":"Octane的TSCTF-J Writeup","url":"/posts/5352/index.html","content":"比赛前早早地注册了Octane的比赛ID，但比赛开始时居然忘了密码，于是只能临时注册了一个Nonane的ID来打orz\n最后拿了个总榜第十一，领到了奖品。同时也学到了很多，看到了自己很多的不足和以后该努力的方向。\n这次比赛主要做的是Crypto和MISC。感觉套路题比较少，至少很无脑的套路不多。比赛前做了一些RSA的简单套路，积累了一点解题脚本，本以为能多水两道，但做比赛才发现Crypto出题人把套路全都放在放在第一道题上了（虽然Padding也是套路题，但到比赛结束也还是没整出来orz）。剩下几道完全是数学题，因为智商不够而被薄纱orz\nMisc的各种图片隐写和压缩包隐写的题型是一道也没考（之前看了去年的隐写题还有点期待今年的来着）。和编码有关的题还出在了Crypto板块中。虽然说隐写题只是和出题人对电波而已…但感觉Black_Tea才是更电波的啊，没见过这种问题就完全没有头绪，上网搜都不知道该搜什么orz。Misc的游戏题确实挺好玩的，也辛苦游戏制作者了。\n比赛题目存档和官方wp：https://github.com/MakeMerakGreatAgain/tsctf-j_2022\nReverseBaby_xor&ensp;&ensp;&ensp;&ensp;签到题,放进IDA里直接F5，可以看到代码。\n\n&ensp;&ensp;&ensp;&ensp;数组data[ ]中每个元素分别与i和0x46进行异或运算即可得到flag\n&ensp;&ensp;&ensp;&ensp;解题脚本：\ndata = [......] # 输入略\nfor i in range(len(data)):\nout.append(chr(i^data[i]^70))\nprint(''.join(out))\n\n# TSCTF-J&#123;W3lC0M3_2_ReVEr$E^xOr_1s_$O0o_e2&#125;\n&ensp;&ensp;\nByte_code&ensp;&ensp;&ensp;&ensp;题目给了一个txt文件，打开后是这样的代码：\n\n&ensp;&ensp;&ensp;&ensp;上网查了一下，这个是Python的字节码。用python -m dis命令即可将py文件转换为字节码。原来想找一个可以将字节码直接转换回py文件的程序，但代码看起来并没有很长，就干脆直接自己对照着字节码写出python代码，每写一行就编译成字节码和原文件对照。最后还原出来的python脚本是这样的，再运行一下就可以得到flag。\na=[114, 101, 118,101,114,115,101,95,116,104,101,95,98,121,116,101]\nb=[99,111,100,101,95,116,111,95,103,101,116,95,102,108,97,103]\ne=[80,115,193,24,226,237,202,212,126,46,205,208,215,135,228,199,63,159,117,52,254,247,0,133,163,248,47,115,109,248,236,68]\npos=[9,6,15,10,1,0,11,7,4,12,5,3,8,2,14,13]\nd=[335833164, 1155265242, 627920619, 1951749419, 1931742276, 856821608, 489891514, 366025591, 1256805508, 1106091325, 128288025, 234430359, 314915121, 249627427, 207058976, 1573143998, 1443233295, 245654538, 1628003955, 220633541, 1412601456, 1029130440, 1556565611, 1644777223, 853364248, 58316711, 734735924, 1745226113, 1441619500, 1426836945, 500084794, 1534413607]\nc=a+b\nfor i in range(31):\n    print(chr(c[i]), end='')\nfor i in range(16):\n    a[i]=a[i]+d[i]^b[pos[i]]\nfor i in range(16):\n    b[i]=b[i]^a[pos[i]]\nc=a+b\nfor i in range(32):\n    c[i]=c[i]*d[i]%256\n    c[i]^=e[i]# 18\n    print(chr(c[i]), end='')\n\n# TSCTF-J&#123;bY7ecoDe_I$_nOT_so_HArd&#125;\n&ensp;&ensp;\nCrypto锟斤拷烫烫烫&ensp;&ensp;&ensp;&ensp;查看题目：\n烫烫烫锟斤拷&#x2F;烫烫烫锟斤拷锟斤拷锟斤拷&#x2F;烫烫烫锟斤拷锟斤拷烫烫烫&#x2F;烫烫烫锟斤拷锟斤拷烫烫烫&#x2F;烫烫烫锟斤拷烫烫烫&#x2F;烫烫烫烫烫烫锟斤拷锟斤拷&#x2F;烫烫烫锟斤拷锟斤拷&#x2F;锟斤拷锟斤拷烫烫烫锟斤拷&#x2F;烫烫烫烫烫烫&#x2F;锟斤拷烫烫烫烫烫烫烫烫烫&#x2F;烫烫烫锟斤拷锟斤拷烫烫烫&#x2F;烫烫烫锟斤拷锟斤拷烫烫烫&#x2F;烫烫烫烫烫烫锟斤拷烫烫烫&#x2F;锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷&#x2F;锟斤拷烫烫烫锟斤拷锟斤拷&#x2F;锟斤拷锟斤拷烫烫烫锟斤拷&#x2F;烫烫烫锟斤拷&#x2F;锟斤拷烫烫烫烫烫烫烫烫烫&#x2F;锟斤拷锟斤拷烫烫烫&#x2F;锟斤拷烫烫烫烫烫烫&#x2F;锟斤拷锟斤拷锟斤拷锟斤拷烫烫烫&#x2F;烫烫烫烫烫烫锟斤拷锟斤拷&#x2F;锟斤拷锟斤拷锟斤拷烫烫烫烫烫烫&#x2F;烫烫烫烫烫烫锟斤拷锟斤拷&#x2F;烫烫烫烫烫烫&#x2F;锟斤拷锟斤拷锟斤拷烫烫烫&#x2F;锟斤拷烫烫烫烫烫烫&#x2F;烫烫烫烫烫烫锟斤拷&#x2F;烫烫烫锟斤拷烫烫烫&#x2F;锟斤拷锟斤拷锟斤拷锟斤拷烫烫烫&#x2F;锟斤拷烫烫烫锟斤拷锟斤拷&#x2F;锟斤拷锟斤拷锟斤拷烫烫烫&#x2F;烫烫烫锟斤拷&#x2F;烫烫烫锟斤拷烫烫烫烫烫烫&#x2F;烫烫烫锟斤拷锟斤拷锟斤拷烫烫烫&#x2F;烫烫烫锟斤拷锟斤拷锟斤拷烫烫烫&#x2F;烫烫烫锟斤拷锟斤拷锟斤拷烫烫烫&#x2F;烫烫烫锟斤拷锟斤拷锟斤拷烫烫烫&#x2F;烫烫烫锟斤拷锟斤拷锟斤拷烫烫烫&#x2F;烫烫烫锟斤拷锟斤拷锟斤拷烫烫烫\n&ensp;&ensp;&ensp;&ensp;虽然”锟斤拷烫烫烫”是一种众所周知的中文乱码，但这种乱码已经丢失了原本的数据，是不能还原出原始信息的！因此这道题不可能是真的”锟斤拷烫烫烫”乱码，而是隐藏着某种别的加密或编码方式。\n&ensp;&ensp;&ensp;&ensp;观察文本内容很容易发现，文段只由”锟斤拷”和”烫烫烫”和斜杠组成。由此很容易想到摩斯电码。\n&ensp;&ensp;&ensp;&ensp;用记事本的替换功能，将”锟斤拷”替换成”.”，将”烫烫烫”替换成”-“，以摩斯电码翻译，得到一串字符：\n\nnbxxkzdfmjxxq5lfnjuw4z3zmvwgk4lvny======\n\n&ensp;&ensp;&ensp;&ensp;观察字符很容易发现，字符尾部有数个等号，并且只有小写字母和数字（因为摩斯电码本身不区分大小写）。很明显是base32编码。将小写字母全部替换为大写字母，进行base32解码，得到柏油校训的拼音，即是flag：\n\nTSCTF-J{houdeboxuejingyelequn}\n\n&ensp;&ensp;\nT0ni’s RSA&ensp;&ensp;&ensp;&ensp;查看题目：\nfrom Crypto.Util.number import *\nfrom gmpy2 import *\nfrom secret import flag\n\nassert len(flag)==48\nflag1=flag[0:12]\nflag2=flag[12:24]\nflag3=flag[24:36]\nflag4=flag[36:48]\n\nprint(\"=====================================flag1\")\nm=bytes_to_long(flag1)\np=getPrime(1024)\nq=getPrime(1024)\ne=65537\nn=p*q\nc=powmod(m,e,n)\nprint(\"p =\",p)\nprint(\"q =\",q)\nprint(\"e =\",e)\nprint(\"c =\",c)\n\nprint(\"=====================================flag2\")\nm=bytes_to_long(flag2)\np=getPrime(64)\nq=getPrime(64)\ne=65537\nn=p*q\nc=powmod(m,e,n)\nprint(\"n =\",n)\nprint(\"e =\",e)\nprint(\"c =\",c)\n\nprint(\"=====================================flag3\")\nm=bytes_to_long(flag3)\np=getPrime(1024)\nq=next_prime(p)\ne=65537\nn=p*q\nc=powmod(m,e,n)\nprint(\"n =\",n)\nprint(\"e =\",e)\nprint(\"c =\",c)\n\nprint(\"=====================================flag4\")\nm=bytes_to_long(flag4)\np=getPrime(1024)\nq=getPrime(1024)\ne=7\nn=p*q\nc=powmod(m,e,n)\nprint(\"n =\",n)\nprint(\"e =\",e)\nprint(\"c =\",c)\n\n# 输出略\n&ensp;&ensp;&ensp;&ensp;由题目可知flag分为四段，分别加密四次，根据每次加密的方式分别解密即可得到flag\n&ensp;&ensp;&ensp;&ensp;解题脚本：\nfrom Crypto.Util.number import long_to_bytes\nfrom gmpy2 import iroot, invert\n\ndef rsa_decrypt(p:int, q:int, e:int, c:int):\n    d = invert(e, (p-1)*(q-1))\n    m = pow(c, d, p*q)\n    return m\n\n# flag1:pq已知，直接用基本方法解密\np0 = 126848068662434725837362927110508359670513097902158347608742478683379412542373205396355795471254038301102414856525121647188484976552142343067044591036870463204973197337043645689668460536955381260032883948287738855267140030987485450026217231376934834164731323791161242646800219869703713605170682364116602398481\nq0 = 108831434115512090318037589335170063989256445400295000303568098461799570376658935415095544400164386313684432766346946165811277996284801631673216470358009654117077854125122927553974223129029217160157869796055967783796164293604324171269850795257143703187899358858675646672321319018167474020363026585548820771697\ne0 = 65537\nc0 = 12806426835071949867711416962709958594314368469792264574105984900555439512183487926101898057954900183669492820478219013019317212504718045553210233002824678962092820191899047884098185828625477721152790480535997733511787559909800255732856472382084502459064555276405636335011653299264667296955585832665754137638936306114164795630686750776282273654483469063781121080308493239356585954141139584326117462247270605137016151223704623131634401478066683053816761883398796060573577823014077050991745590269109018594293646949390055766822956018083267147781811450534232319486801350308073725708881185484667042111239958769639753074974\nm0 = long_to_bytes(rsa_decrypt(p0, q0, e0, c0))\n\n# flag2:p和q都比较小，可以直接用yafu分解n，得到p1和p2，再解密\np1 = 10044079891992334031\nq1 = 11695298459661145481\ne1 = 65537\nc1 = 116661533228458434140621528983098975679\nm1 = long_to_bytes(rsa_decrypt(p1, q1, e1, c1))\n\n# flag3:p和q是相邻质数，也能很容易用yafu分解n得到pq\nq2 = 116157631074161326668152038927249334338399827206586914589176832177082944299227717473355044107614652079152523161147120835537353552449908708629934368874677505050900078018992526314964561246045453416854196152086105218778204572329269076361235953745958869643828443636138454981800813514293034142691705140488032064827\np2 = 116157631074161326668152038927249334338399827206586914589176832177082944299227717473355044107614652079152523161147120835537353552449908708629934368874677505050900078018992526314964561246045453416854196152086105218778204572329269076361235953745958869643828443636138454981800813514293034142691705140488032060333\ne2 = 65537\nc2 = 9556855627975459046740821834528544070427049621127160951742003478725424449033433009828717934730280978533743220944726870403563278379897696996593408941742726761954126312142544881536075456011232335038713394388844246035946642298588354835538957640121051986433171003548328013363624428388045689223434747553158248457199579326477645217581943607544640937724609291757178063476167129106555047385785925998650584941948353305651394629383203202173799027705269424908549510903196317581322985993424298619576745664607011471390391051884932663025002185768778902167735501719300645089512150938345539777564021221129832163135987500087303945958\nm2 = long_to_bytes(rsa_decrypt(p2, q2, e2, c2))\n\n# flag4:低指数小明文攻击，直接将c开e次方即可\ne3 = 7\nc = 24352183908812439486066187971806232095447207924326195067955513727448051350160252184726311366048048945796542616778567176778473328388848916602914602254361942853429047133399539108358587787495587158203125\nm3 = long_to_bytes(iroot(c, 7)[0])\nprint(m0 + m1 + m2 + m3)\n\n# TSCTF-J&#123;T0niii_is_the_most_handsome_boy_in_BUPT&#125;\n&ensp;&ensp;\nNonograms\n&ensp;&ensp;&ensp;&ensp;似乎是某种填字游戏，总共14张图。曾经在steam玩过玩法类似的SquareCells。\n&ensp;&ensp;&ensp;&ensp;hint提示用画图的填充工具做，本想找到一个可以在线解密的网站。但最后还是自己做了。\n&ensp;&ensp;&ensp;&ensp;先在前几个挑了几个简单的做，得到这个\n\n&ensp;&ensp;&ensp;&ensp;由此可知前8个图是’TSCTF-J{‘。最后一个图是’}’。因此中间9-13五张图才是flag的实际内容。\n\n&ensp;&ensp;&ensp;&ensp;由此很容易可以猜测出flag：\n\nTSCTF-J{旗开得勝！}\n\n&ensp;&ensp;\nTwo Keys\n&ensp;&ensp;&ensp;&ensp;由题目描述可知flag分为两段，分别用key和KEY加密。\n&ensp;&ensp;&ensp;&ensp;第一段flag用RSA加密，p、q、phi都是已知的，而e就是key，即是Question1的答案。\n\n&ensp;&ensp;&ensp;&ensp;询问出题人这个问题的具体规则，得知不能走回头路，整个过程只能网上或往右走。\n&ensp;&ensp;&ensp;&ensp;虽然不会算这种问题，但可以估计最终的答案不会非常大。能爆破的题为什么还要动脑算？\n&ensp;&ensp;&ensp;&ensp;于是写一个脚本直接爆破e解密，从而得到第一段flag。\nfrom gmpy2 import invert\nfrom Crypto.Util.number import long_to_bytes\n\nn = int('7a9a4979dd59cd8b38706b0920ffc1d63ee9c6c94cc6bf097c0957d5017b6562d7b03f396b9cd1f9e6a7303522effe632422c44360c66fe8526ff997db1496f2c1a70ab179f59f5fc4b1dd5513cc663d811b50e1c2b29dfa1ae5228b1fd2b7b65595c4486eb3d22fbd2b6fba58b4f299f07a73fc90e97af9781156afb0af32a02a4a1198b734fa2fefdfd64d2767e095db30919a6cbf3de0217f949d9b46e704a3cefe3af62fdfdd702e439ef423e7582d6b67903a1c956d1d7f3a62baa217f2c47d81c08f9734eb19f13c9bcd3d55c098498af02aa4dc5449668682a150050675d0b74e9dfb2698031dcbd726da450c62f48a4b24ab2da2d8bd2b1421000361', 16)\nphi = int('7a9a4979dd59cd8b38706b0920ffc1d63ee9c6c94cc6bf097c0957d5017b6562d7b03f396b9cd1f9e6a7303522effe632422c44360c66fe8526ff997db1496f2c1a70ab179f59f5fc4b1dd5513cc663d811b50e1c2b29dfa1ae5228b1fd2b7b65595c4486eb3d22fbd2b6fba58b4f299f07a73fc90e97af9781156afb0af329ec7f057b665e05893cc0d6c79028fb4786e44d66c74dd79a180ad035f8de4256d8b988038fa097a526dcc55678d80cf651b40965b08ee40d2c733220bd6fbdaebd13175d04a1498c16436f93e8d441f74d1ed77eecb9866f0c02a07c1bc1021d4329c2d8211f3e60f8bfc409c5a7424cfb7dc5d7f97a932f9eb303741bb9312c0', 16)\nc = int('57765d8a8d0d74a3f6e3151cc1276b8db6e790d691f7d06713c1d5791164902f6add5a4350512225034d114ae59603a431d1b8ebc956bdc30a3d69cc364649dada23153483bfbf1cfb06ffb22ca9e969674d68a2dae6c9482dfe7b95561035396996473d37cdae2c7e6bda62face36d487d31810cad3382a37c881ea694eb45b4a1788eb1f7865ff3105a3669e7bf39bb0e04d46b98acbfefbdebeb3c2e967e1db553420337db750805d08483760f7abb9ad69d4fc489ec3c2cc9c10778fe03090b8b0b33854047aafab676c4a2a4d6b94b4df6e2ed6f23d9ba6e8713cbeeb5aab5bbf23558afade67460d2561f0a60a26a8c064550eb858b8e25fcf72bcb581', 16)\n\ne = 1\nwhile True:\n    try:\n        d = invert(e, phi)\n        m = pow(c, d, n)\n        out = long_to_bytes(m)\n        print(str(out.decode('utf-8', 'strict')))\n        break\n    except:\n        e += 1\n        continue\n\n# TSCTF-J&#123;C0mbinAt0rial_M4themat1cs_aNd_\n&ensp;&ensp;&ensp;&ensp;Qustion2：\nprint(\"Question 2:\\n\\nKEY is a string of 8 lowercase letter.\\n\\nsha256(KEY) == 2b87ea3983c646fcecc476f6930c18bf75935cab40471930f560bef2f370b82e and len(KEY) == 8\\n\")\n&ensp;&ensp;&ensp;&ensp;第二段flag用DES加密，密钥KEY就是Question2的答案。Question2给出了KEY的sha256哈希值，并且已知KEY由八个小写英文字母组成。于是用hashcat进行哈希碰撞得到KEY：\n\n&ensp;&ensp;&ensp;&ensp;很快就可以解出KEY是’vmefifty’。用KEY解密DES密文即可得到第二段flag：\nfrom Crypto.Cipher import DES\n\ncipher2 = b'\\x83\\xce\\x8a\\xdac)\\xd2\\xa41\\xe26\\xd5\\x12\\xcf\\x9aV;%\\x80\\xc1\\x87\\x97\\xe0\\xc3\\x03\\x17\\xfeR\\x97b\\x86\\xf9\"\\x1c\\xde\\xf4\\xc1F\\xd5\\x13\\x1e$\\xc3\\xb8\\x84Z&#125;\\xac'\nKEY = b'vmefifty' # 由hashcat得到的KEY\n\ngenerator = DES.new(KEY, DES.MODE_ECB)\nprint(generator.decrypt(cipher2))\n\n# Ha$h-Alg0rithms_aRe_1mportaNt_in_CryptOgraphy&#125;\n&ensp;&ensp;&ensp;&ensp;最终得到完整flag：\n\nTSCTF-J{C0mbinAt0rial_M4themat1cs_aNd_Ha$h-Alg0rithms_aRe_1mportaNt_in_CryptOgraphy}\n\n&ensp;&ensp;\nT0ni’s Encode&ensp;&ensp;&ensp;&ensp;查看题目：\nfrom Crypto.Util.number import *\nfrom secret import flag,key\n\ndata=b'abcdefghijkl0123456789'\nfor i in range(len(key)):\n    assert key[i] in data\n\ndef T0nihash(a,b):\n    if(bytes_to_long(b+a)!=0):\n        return long_to_bytes((bytes_to_long(a)*bytes_to_long(a+b))%bytes_to_long(b+a))\n    else:\n        return b'hahahahaha'\n\nhint=b'thisishint'\ncipher=b''\nassert flag[0:10]==b'TSCTF-J&#123;Ba'\n\nfor i in range(len(flag)//5):\n    tmp=flag[5*i:5*i+5]\n    if(sum(tmp)%2==0):\n        cipher+=long_to_bytes(bytes_to_long(tmp)^bytes_to_long(key[0:5]))\n        key=T0nihash(key[0:5],key[5:10])\n        hint=T0nihash(hint[0:5], hint[5:10])\n    else:\n        cipher+=long_to_bytes(bytes_to_long(tmp)^bytes_to_long(key[5:10]))\n        key=T0nihash(key[5:10],key[0:5])\n        hint=T0nihash(hint[5:10], hint[0:5])\n\nprint(\"cipher =\",cipher)\nprint(\"hint =\",hint)\n\n# 输出略\n&ensp;&ensp;&ensp;&ensp;分析题目，首先已知’key’中的字符一定在’data’里，即一定是小写字母和数字。并且题目给出了明文即flag的前十个字符’TSCTF-J{Ba’。\n&ensp;&ensp;&ensp;&ensp;分析加密过程，首先题目将flag明文按每五个字符分为一组，分组进行加密。每一组的明文的sum如果能被2整除，该组明文与key的前五位进行异或运算；当明文的sum不能被2整除时，明文与key的后五位进行异或运算。两种情况都在加密后用’T0nihash’函数对key进行一次变换，并且变换时key的前五位和后五位的前后顺序不同，以使得每一组加密时使用的密钥都互不相同。\n&ensp;&ensp;&ensp;&ensp;从加密过程可以得知，加密前后各组数据的顺序和大小都没有改变，密文的第n位一定对应明文的第n位。而每一次加密的步骤用的是可逆得到异或运算。我们已知前两组加密使用的明文分别是’TSCTF’和’-J{BA’，因此很容易求出加密前两组使用的密钥。由于解密和加密的顺序系统，解密时密钥的变换方式与加密时相同，因此我们只要知道初始密钥，再按与加密相同的步骤依次进行异或运算即可得到明文。\n&ensp;&ensp;&ensp;&ensp;首先分别求出前两组明文的sum，以判定它们时以key的前五位还是后五位加密的。\nknown = b'TSCTF-J&#123;Ba'\nprint(sum(known[:5])%2) # 0\nprint(sum(known[5:10])%2) # 1\n&ensp;&ensp;&ensp;&ensp;由此可知第一组明文是与初始状态key的前五位进行异或运算的。而第二组明文是与经过一次变换的key的后五位进行异或运算的。由已知的明文与对应的密文进行异或运算得到对应的key：\nkey1 = long_to_bytes(bytes_to_long(cipher[:5])^bytes_to_long(known[:5]))\nprint(key1) #b'a2002'\n\nkey02 = long_to_bytes(bytes_to_long(cipher[5:10])^bytes_to_long(known[5:10]))\nprint(key02) #b'06\\x97~d'\n&ensp;&ensp;&ensp;&ensp;我们由此得知初始key的前五位是’a2002’。但第二次得到的key的后五位，即key02看起来是乱码，这是因为它是经过一轮’T0nihash’变换之后的key。’T0nihash’函数是已知的，我们可以以此进一步推算出初始密钥的后五位。\n&ensp;&ensp;&ensp;&ensp;’T0nihash’函数含有取余运算，直接逆推非常困难。但我们知道初始key只含有数字和小写字母，因此我们可以对初始key的后五位进行爆破。当初始key的前五位和初始key的后五位的’T0nihash’运算结果与key02相同时，我们就找到了正确的初始key。爆破脚本如下：\nkey1 = b'a2002'\ndef brute_5bytes():\n    table = b'abcdefghijkl0123456789'\n    for h in table:\n        for i in table:\n            for j in table:\n                for k in table:\n                    for l in table:\n                        tmp = (chr(h)+chr(i)+chr(j)+chr(k)+chr(l)).encode()\n                        if T0nihash(key1, tmp)[5:10]== b'06\\x97~d':\n                            print(tmp)\n                            return\n\nbrute_5bytes()\n# key = b'a20021130a'\n&ensp;&ensp;&ensp;&ensp;由此可知初始key是’a20021130a’\n&ensp;&ensp;&ensp;&ensp;我们得到了初始key，即可进行解密。解密的顺序和加密的顺序相同，均为从前往后，并且加解密时密钥的变换方式相同。由于我们不知道每一组的明文的sum值，因此要用try-except语句尝试两种情况。解密脚本如下：\nfrom Crypto.Util.number import long_to_bytes, bytes_to_long\n\ndef T0nihash(a,b):\n    if(bytes_to_long(b+a)!=0):\n        return long_to_bytes((bytes_to_long(a)*bytes_to_long(a+b))%bytes_to_long(b+a))\n    else:\n        return b'hahahahaha'\n\nkey = b'a20021130a'\ncipher = b\"5asdt\\x1d|\\xec&lt;\\x05\\x0e(\\x02\\xe7\\xae\\t\\xeeq+\\x0fq\\x0c\\xd0\\xe5e'\\xede\\xb38\\xca\\x90\\x1b'\\x04pWx\\xb1\\xc1nk\\xdbzmr\\xd4^\\x95l\\xa3L\\xb1\\x19\\xf5v\\xe1\\xfb\\xd5\\xa2/\\xca\\x00\\xd9\\r\\x1d\\xf2\\xffw\\xee\\x1a\\xf9z\\x9dT.\\xa1\\xee$&#125;\"\nknown = b'TSCTF-J&#123;Ba'\nout=''\n\nfor i in range(len(cipher)//5):\n    tmp=cipher[5*i:5*i+5]\n    try:\n        out+=str(long_to_bytes(bytes_to_long(tmp)^bytes_to_long(key[0:5])).decode('utf-8', 'strict'))\n        key=T0nihash(key[0:5],key[5:10])\n    except:\n        out+=str(long_to_bytes(bytes_to_long(tmp)^bytes_to_long(key[5:10])).decode())\n        key=T0nihash(key[5:10],key[0:5])\nprint(out)\n\n# TSCTF-J&#123;Bartleby_is_really_clever_and_his_math_is_much_better_than_T0ni_TATATAT&#125;\n&ensp;&ensp;&ensp;&ensp;flag终于求出来了…但hint是啥？懒得看了。\n&ensp;&ensp;\nL1nearAlgebra&ensp;&ensp;&ensp;&ensp;先看题目：\nfrom sage.all import *\nimport os\n\nflag = flag + os.urandom(62 - len(flag))\nM = Matrix(32,32)\nfor i in range(32):\n        M[i,i] = 2\nfor i in range(31):\n        M[i,i+1] = 1\nC = Matrix(32,32)\nidx = [i for i in range(1,32)]\nfor each , i in zip(flag[:31],idx):\n    C += each * M ^ i\nM = M.transpose()\nfor each, i in zip(flag[31:],idx):\n    C += each * M ^ i\nf = open('cipher.txt','w')\nf.write(str(list(C)))\nf.close()\n&ensp;&ensp;&ensp;&ensp;大概题目就是先造了一个矩阵M，然后把很多矩阵M用flag经过某种变换后叠在矩阵C上。但每叠一个矩阵M之后矩阵C的第一行和第一列的最后一个数就是上一个叠的矩阵M乘以的因数，也是flag的ASCII码。逐个把这个数取出来并减去相应的矩阵，就可以得到flag了。\n&ensp;&ensp;&ensp;&ensp;矩阵运算用的是sympy库。解题脚本：\nfrom sympy import Matrix, zeros\n\nC = Matrix(......) # 输入略\nM = zeros(32,32)\nfor i in range(32):\n        M[i,i] = 2\nfor i in range(31):\n        M[i,i+1] = 1\n\ncleartxt1 = []\ncleartxt2 = []\n\nfor i in range(1,32):\n    tmp1 = C[31,i-1]\n    tmp2 = C[0,32-i]\n    C -= M.T**(32-i)*tmp1\n    C -= M**(32-i)*tmp2\n    cleartxt1.append(chr(tmp1))\n    cleartxt2.append(chr(tmp2))\n\noutput = ''\nfor i in range(len(cleartxt1)*2):\n    output += (cleartxt1+cleartxt2)[len(cleartxt1)*2-1-i]\nprint(output)\n\n# TSCTF_J&#123;Jordan_Matrix_is_Important_in_L1near_Algebra&#125;Z1uÊ­l°uw\n&ensp;&ensp;&ensp;&ensp;flag提到了个叫Jordan矩阵的东西。之前没有了解过这个，等以后有时间的时候一定研究一下。\n&ensp;&ensp;\nMisc北邮人之声&ensp;&ensp;&ensp;&ensp;题目是一段倒放的音频。用Audacity的 效果-反相（时间） 选项处理音频，再适当降低速度，提升音高使语音更容易分辨。按国际航空无线电的字母读法听，即可听出flag。\n\nTSCTF-J{WELCOMETOBUPT}\n\n&ensp;&ensp;\nJust_Play&ensp;&ensp;&ensp;&ensp;一个奇怪的rpg。整个流程比较短。flag分为四个部分，每部分之间用下划线连接。首先翻一下游戏文件，找到FF.mp3，进行一段极其抽象的英语听力得到flag part4。在游戏中完成游戏流程，集齐宝石得到part3，击败最终boss bridge得到part1。在flag图迷宫的地形里可以看到由墙组成的part2。最后全部组合起来即是flag：\n\nTSCTF-J{Th1s_G4mE_1s_S0_Ez2zZzz_4_Y0U_ri9h7?}\n\n关于游戏：&ensp;&ensp;&ensp;&ensp;在游戏里找到茯苓，输入暗号”1919810”可以解锁非常强的角色，前期打小boss和刷钱很快。但最终打bridge时这个角色会被ban掉。\n&ensp;&ensp;&ensp;&ensp;塔上有坑。上塔之前最好备份一下存档。\n&ensp;&ensp;&ensp;&ensp;游戏中的字体的0和O很难区分，从游戏中读flag时也要注意一下。\n&ensp;&ensp;\nstrange base64&ensp;&ensp;&ensp;&ensp;只要写一个交互脚本把777个base64接收后解码成字节再发送出去就可以。默认编码即可，不用特意考虑中文编码问题。\n&ensp;&ensp;&ensp;&ensp;解题脚本：\nimport base64\nfrom pwn import *\n\nio = remote('xxx.xxx.xxx.xxx', xxxxx) # 题目环境ip地址+端口号\nfor i in range(777):\n    io.recvuntil(b'\\'')\n    input = io.recvuntil(b'\\'')\n    io.recvline()\n    input = input[:-1]\n    print(input)\n    v1 = base64.b64decode(input)\n    v3 = v1.decode()\n    print(v3)\n    io.sendline(v3)\n    print(io.recvline())\nio.interactive()\n\n# TSCTF-J&#123;easytointeractive&#125;\n&ensp;&ensp;\n赛后问卷&ensp;&ensp;&ensp;&ensp;略\n&ensp;&ensp;\nWeb词超人&ensp;&ensp;&ensp;&ensp;题目是一个单词测试的网站，题很多，似乎全部做对才能得到flag。但每道题的答案都直接在网页源代码里给了出来。用BurpSuite抓包发现判题的机制是网页将每道题的id和用户填写的答案POST给服务器，再由服务器返回结果。因此，可以用Word的搜索/替换功能，将网页源代码保留题目ID和答案，替换成网页POST给服务器的格式，发送给服务器就可以返回flag: \n\nTSCTF-J{naughty_or_diligent-which_type_you_are?^_^}\n\n&ensp;&ensp;\n真真历险记&ensp;&ensp;&ensp;&ensp;进网页后按F12，在源代码的style.css里可以找到三段奇怪的注释，只由[(])+!几个字符组成，很明显是JSf*ck，将三段编码连起来，用解码即可得到flag\n&ensp;&ensp;&ensp;&ensp;http://www.hiencode.com/jsfuck.html\n&ensp;&ensp;&ensp;&ensp;需要注意的是，由于Jsf*ck的特性，分别解码是不能得到完整的flag的，必须将三段代码按顺序连起来一起解码才能得到flag：\n\nTSCTF-J{1_tEs7_y0Ur_c()de}\n\n&ensp;&ensp;\nPwncheckin&ensp;&ensp;&ensp;&ensp;是非常简单的栈溢出，直接nc题目地址，只要溢出就能得到flag。flag具体是啥忘了。\n&ensp;&ensp;\n&ensp;&ensp;\nEnd总之，感谢学长们用心准备的这次比赛。之后有时间的时候会把今年MoeCTF的WP给整理一下发出来。因为它虽然是西电的新生赛，但其中很多题和想法对我自己来说还是很有价值的，同时很多做题时学到的知识和思路也快忘记了，整理一遍wp也权当复习，作为笔记放在这里给自己参考和提示。（意识到写wp的重要性）\n","categories":["Writeup"],"tags":["CTF","Writeup"]},{"title":"(水)关于linux系统网卡驱动的安装","url":"/posts/17920/index.html","content":"作为一个刚刚接触linux系统的小白，目前还在熟悉linux下一些基本操作的方法。（Debian系统）\n刚好有个闲置的usb无线网卡，是Tenda的某个型号。想把它安装在linux上来连接学校的无线网。\n连接在电脑上之后发现识别不了网卡。于是花了点时间解决这件事情。虽然没什么技术含量，但很多东西也是我第一次接触，因此在这里记录一下步骤和踩过的坑。\n0x01 RTL8192FU连接网卡？&ensp;&ensp;&ensp;&ensp;先用lsusb查看一下usb网卡有没有正确连接到linux上。\n\n&ensp;&ensp;&ensp;&ensp;正常来说网卡在lsusb上会显示为 WLAN Adapter，在这里却显示为DISK。突然想起这个网卡是“免驱型”，插在windows系统上不会立刻显示为网卡，而是显示为一个CD-ROM来提供windows下的驱动安装程序，将CD驱动器右键弹出才能作为网卡使用。\n\n&ensp;&ensp;&ensp;&ensp;查阅网络了解到，linux命令行中实现该操作的命令是”eject”。先在debian软件包仓库手动下载一个eject的.deb包，再离线拷贝到linux系统上安装，将 /dev/sr0 分区弹出，然后就可以在lsusb看到网卡了。（如果安装的是Desktop版linux，直接右键光盘点弹出即可）\n\n寻找网卡驱动&ensp;&ensp;&ensp;&ensp;因为之前在windows下用过这个usb网卡，所以知道芯片是RTL8192FU。因此直接按照网卡芯片的型号在github上搜索驱动的源代码。https://github.com/BrightX/rtl8192fu\n&ensp;&ensp;&ensp;&ensp;下载解压出来拷贝到U盘，插到linux上。\n编译并安装驱动&ensp;&ensp;&ensp;&ensp;网卡驱动应该和一般的程序安装步骤差不多，首先要从官网下载对应版本的linux-header内核头文件并拷贝到linux安装，然后在程序的源代码根目录下建立Makefile，用make和make install编译安装。\n&ensp;&ensp;&ensp;&ensp;在根目录下已经发现了Makefile，直接 make &amp; make install即可安装驱动。\n\n有些linux系统发行版（比如Ubuntu LTS 22.04），刚装好系统时甚至连安装网卡驱动需要的编译环境（gcc编译器、make）都没有。而在没有网卡驱动，无法联网的情况下也不可能用apt包管理器来安装这些工具。对于一些比较简单的程序，可以直接去系统的官方软件包仓库https://www.debian.org/distrib/packages在线下载.deb包，再拷贝到linux上用dpkg离线安装。但对于gcc、make这样的程序，依赖的库比较多。对应着依赖关系表，挨个手动下载.deb包是一件非常折磨的事情。\n这种情况下有一个比较自动的解决方案，就是在自己的电脑上配置一个和该linux系统相同的虚拟机，将该虚拟机连接网络，在该虚拟机上安装apt-rdepends\nOctane@vmware:~$ sudo apt install apt-rdepends\n这个工具可以帮助我们获取一个软件包的依赖。我们可以利用这个工具配合apt下载软件包依赖的所有包和库。\nOctane@vmware:~$ apt-get download $(apt-rdepends gcc make|grep -v \"^ \")\n然后将下载的.deb软件包拷贝到linux系统上，用dpkg安装即可。\n但要注意，这个方法一定要在和需要安装依赖的linux系统版本完全相同的虚拟机上使用。如果用的系统有区别，即使使用的包管理器是相同的（如Ubuntu和Kali），但由于不同linux版本使用的软件包仓库不同，安装后本地依赖关系会变得一团糟。虽然此时有了gcc和make，可以编译和安装网卡驱动，也可以正常联网，但连上网后apt无法安装或卸载任何软件包，aptitude都没法安装了，也无法自动修复依赖关系。我当时到这里没有办法让系统恢复正常，只能重装了orz。\n\n\n&ensp;&ensp;&ensp;&ensp;但安装过程中出现了一个报错。大概的意思是Makefile的修改时间要比系统时间要晚，因此编译很可能失败。这是因为刚烧录好的系统，系统时间是比较之前的，而且在没有联网的情况下也无法同步时间到最新。为解决这个问题，将系统时间手动调整，调到Makefile的修改时间之后即可。用make clean清理一下，再用make重新编译。\n&ensp;&ensp;&ensp;&ensp;然后make install，顺利地安装上了网卡驱动。\n&ensp;&ensp;&ensp;&ensp;此时用nmcli dev wifi搜索网络，可以正常连接portal校园网，至此网卡安装完毕。\n&ensp;&ensp;&ensp;&ensp;至于校园网的连接，我使用的这个linux没有安装x-server，也就是说不能用有图形界面的浏览器。但对于linux的命令行，有一个傻瓜式文本浏览器w3m可供使用。用这个浏览器可以轻松在页面填写账号登录校园网。\n0x02 RTL8192EU&ensp;&ensp;&ensp;&ensp;又是另外一个USB无线网卡，芯片是8192EU。似乎要比8192FU友好一些，插入电脑就能自动用lsusb识别到型号，ifconfig也可以识别到网卡。但信号似乎很差，而且网络完全连不上…\n\n&ensp;&ensp;&ensp;&ensp;看来还是要装驱动。于是又从Github搜索到了相应的驱动。\n&ensp;&ensp;&ensp;&ensp;老办法，解压，拷贝，Make &amp; Make install 安装…一切看起来都很顺利，再连接一下网络，为什么还是和之前一样无法连接??难道网卡是坏掉的…?\n&ensp;&ensp;&ensp;&ensp;上网查阅了一下资料，linux内核模块本身就带有支持RTL系无线网卡的驱动（rtl8xxxu），而RTL8192EU是兼容这个驱动的，因此能被linux自动识别的。信号不好和无法连接是由于这个驱动对这个网卡的支持比较差。用 make &amp; make install 安装该驱动后，设备使用的还是内核的驱动。因此想要让我们安装的驱动发挥作用，就需要把内核模块中默认的rtl8xxxu驱动换掉。\noctane@octanePC:/mnt/sda/rtl8192eu-linux-5.11.2$ sudo rmmod rtl8xxxu\noctane@octanePC:/mnt/sda/rtl8192eu-linux-5.11.2$ sudo echo \"blacklist rtl8xxxu\" >> /etc/modprobe.d/blcaklist-rtl8xxxu.conf\noctane@octanePC:/mnt/sda/rtl8192eu-linux-5.11.2$ cp -ar . /usr/src/rtl8192eu-1.0\noctane@octanePC:/mnt/sda/rtl8192eu-linux-5.11.2$ sudo dkms add -m rtl8192eu -v 1.0\noctane@octanePC:/mnt/sda/rtl8192eu-linux-5.11.2$ sudo dkms install -m rtl8192eu -v 1.0\n&ensp;&ensp;&ensp;&ensp;然后就可以正常使用了。性能感觉比8192FU还好一些。\n&ensp;&ensp;&ensp;&ensp;而之前的RTL8192FU，由于它本身就不兼容内核中的rtl8xxxu驱动。因此用 make &amp; make install 直接安装驱动，不将驱动整合进linux内核也可以使用。\n0x03 总结？&ensp;&ensp;&ensp;&ensp;总之，最好的办法就是使用与linux内核兼容的网卡。大多数笔记本内置的intel无线网卡一般都是内核自带驱动的，实测AC3165、AC9560、AX200、AX211都可以直接兼容linux5.，不用安装驱动就能很好地工作。需要usb无线网卡时优先选择标明网卡芯片的型号的。其次再选非免驱版，自己查看网卡芯片型号并安装驱动。免驱版因为有一个驱动安装的分区，每次使用前要先弹出一下，对linux的使用不是很友好。\n","categories":["notes"],"tags":["notes"]},{"title":"Hello_World","url":"/posts/61920/index.html","content":"终于把博客搭好了…目前页面还比较简陋，但至少能上了（大概\n以后主要会在博客更新参加过的CTF的Writeup、做题和学习记录。也会贴一些可能没什么技术含量的笔记，比如一些配置环境时遇到的问题。\n","categories":[],"tags":[]}]